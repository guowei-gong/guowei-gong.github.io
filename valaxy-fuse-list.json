[{"title":"2022总结与2023年计划","tags":[],"categories":"朝花夕拾","author":"龚国玮","excerpt":"\n标题纠结了一会儿，是应该叫 2022 小结还是 2022 总结呢？因为这一年感觉一眨眼就过去了，记得我爸曾经对我说过，人过了 20 岁，日子就会过的很快了。又让他说中了。\n\n","link":"/posts/2022-summary-and-2023-plans","content":"\n标题纠结了一会儿，是应该叫 2022 小结还是 2022 总结呢？因为这一年感觉一眨眼就过去了，记得我爸曾经对我说过，人过了 20 岁，日子就会过的很快了。又让他说中了。\n\n<!-- more -->\n\n# 2022 总结\n## 一 定位\n一月入职了二次元手游公司，决定自己的行业经验就选游戏了。我认为自己是幸运的，从决定转 Go 到找到工作，我花了 2 个月的时间。可能是因为自己就一个人吧，属于一人吃饱，全家不饿。自己对于工作地点无限制，哪里有机会，我就可以背起行囊，所以从厦门来到了上海。\n## 二 新冠\n上海三月、四月、五月封城，这段时间合租的室友都不在，一个是年后就没来了，还有一个是医生，封城的时间都在医院🏥。所幸医生小姐姐平时有做饭的习惯，锅碗盆瓢齐全，借用她的厨具与自己艰难的抢菜，度过了这段时间。\n## 三 房贷\n背了 30 年商业房贷。如果是按月还，说实话，目前的薪资没什么压力，但是压力来自 30 年，我不知道自己能不能还到 50 多岁。自己老家也不是钦州，也不会去那里住。5 年之内一次性还清吧。\n## 四 朋友\n明子 2021 年脱产考研了，前几天刚考完，还没出结果，希望他能够一切顺利。\n高中舍友骚🐻结婚了，让我 1 月 11 号去参加，去不了，票买不着。真没想到他会是朋友中第一个结婚的。\n## 五 坚持\n- 坚持看书，感觉每天都在看书\n- 坚持运动，坚持了 1 个月\n- 坚持背英语单词，坚持了半年\n## 六 书单\n读完的书，没读完的就不列出来了，希望 2023 年能够把没有读完的读完，加油啊。\n- 《Go并发编程实战》郝林\n- 《Go语言设计与实现》德莱文\n- 《Go语言圣经》\n- 《Go语言专家编程》华为\n- 《深入浅出Docker》\n- 《Go语言学习指南：惯例模式与编程实践》\n- 《Go语言第一课》极客时间\n- 《Go 并发编程实战课》极客时间\n## 写在最后\n为什么关键词里没有家人，因为家人是永远的关键词，我爱你们！\n\n# 2023 计划\n目标以可量化的形式设定，方便 2024 年总结的时候考察完成情况。\n- 注重身体健康，早睡早起，少奖励自己，体重维持在 60 Kg 左右\n- 每天坚持刷 leetcode，目标是 1000 题\n- 加强基础。读完 CSAPP，并每天做好笔记\n- 坚持每周写 1 篇博客，多思考多总结，博客不少于 50 篇\n- 学习至少 2 项新技术/知识领域，并写博客记录\n- 存钱，每个月薪资的 60 %\n- 吉他可以完整指弹 1 首曲子\n- 带家人旅游 1 次\n- ~~跟女孩子说 5 句话~~\n\n2023 年 1 月 4 日力扣题目截图：\n\n![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e26750a3325f44e8a74b0029bb061474~tplv-k3u1fbpfcp-watermark.image?)"},{"title":"我说我为什么抽不到SSR，原来是这段代码在作祟","tags":["Go","随机加权"],"categories":"游戏","author":"龚国玮","excerpt":"\n当我们从某种容器中随机选择一个元素，每个元素被选中的机会并不相等，而是由相对“权重”（或概率）被选中的，也就是说我们想要有“偏心”的得到某种随机结果。\n\n","link":"/posts/can-not-draw-SSR","content":"\n当我们从某种容器中随机选择一个元素，每个元素被选中的机会并不相等，而是由相对“权重”（或概率）被选中的，也就是说我们想要有“偏心”的得到某种随机结果。\n\n<!-- more -->\n\n## 介绍\n\n首先，什么是加权随机？当我们从某种容器中随机选择一个元素，每个元素被选中的机会并不相等，而是由相对“权重”（或概率）被选中的，也就是说我们想要有“偏心”的得到某种随机结果。举一个例子，假如现在有一个权重数组 w = {1, 2, 4, 8}，它们代表如下规则。\n\n- $\\frac{1}{(1+2+4+8)} = \\frac{1}{15} \\approx 6.6$ \\% 的机会选中索引 0\n\n- $\\frac{2}{(1+2+4+8)} = \\frac{2}{15} \\approx 13.3$ \\% 的机会选中索引 1\n\n- $\\frac{3}{(1+2+4+8)} = \\frac{4}{15} \\approx 26.6$ \\% 的机会选中索引 2\n\n- $\\frac{1}{(1+2+4+8)} = \\frac{8}{15} \\approx 53.3$ \\% 的机会选中索引 3\n\n在游戏开发的过程中，很多场景都会用到加权随机。例如游戏中的抽奖，我们有 50% 的几率获得金币、40% 的几率获得钻石、9% 的几率获得普通装备，1% 的几率获得极品装备。\n再比如 nginx 的配置中，也有权重配置。\n\n## 解决方案\n\n### 方案一\n第一个方法是在我们的候选列表中，包含了基于权重的每个索引的预期数量，然后从该列表中随机选择。\n\n假设现在有权重列表 {1, 2, 4, 8}，那我们得到的候选列表将是 {0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3}。\n\n然后通过 rand.Intn() ，获取一个随机数，就完成了，代码如下。\n\n```go\nfunc weightedRandomS1(weights []int) int {\n\tif len(weights) == 0 {\n\t\treturn 0\n\t}\n\n\tvar indexList []int\n\n\tfor i, weight := range weights {\n\t\tcnt := 0\n\t\tfor weight > cnt {\n\t\t\tindexList = append(indexList, i)\n\t\t\tcnt++\n\t\t}\n\t}\n\n\trand.Seed(time.Now().UnixNano())\n\treturn indexList[rand.Intn(len(indexList))]\n}\n```\n\n### 方案二\n\n使用方案一，当权重特别大的时候，这种方案显然效率不高，会浪费很多时间来生成列表，并占用太多的内存。\n\n方案一中的列表不是必须的，方案二避免生成大的列表。由于总权重为 15（1+2+4+8），我们可以生成一个 [0,15) 的随机整数，然后根据这个数字返回索引。代码如下。\n\n```go\nfunc weightedRandomS2() int {\n\trand.Seed(time.Now().UnixNano())\n\tr := rand.Intn(15)\n\tif r <= 1 {\n\t\treturn 0\n\t} else if 1 < r && r <= 3 {\n\t\treturn 1\n\t} else if 3 < r && r <= 7 {\n\t\treturn 2\n\t} else {\n\t\treturn 3\n\t}\n}\n```\n\n### 方案三\n\n方案二避免了方案一中的生成列表，因此效率更高了。但是我们必须写很多的 if else 代码，这看起来太难看了，为了避免编写过多的 if else 代码，衍生出了方案三。\n\n不必将 r 与所有的范围进行比较。我们可以依次减去总权重，任何时候结果小于等于零，我们就可以返回它。这种方法可以叫做放弃临时名单。\n\n```go\nfunc weightedRandomS3(weights []int) int {\n\trand.Seed(time.Now().UnixNano())\n\tr := rand.Intn(15)\n\tfor i, v := range weights {\n\t\tr = r - v\n\t\tif r <= 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn len(weights) - 1\n}\n```\n\n### 方案四\n\n对于方案三，r 小于等于 0 的速度越快，我们的算法就越高效。那么我们如何让 r 到达 0 更快呢？\n\n直观感受上，如果 r 减去最大的权重，就会更快到达 0 ，所以在运行 weightedRandom 前，我们可以对 weights 按照权重从大到小排序。\n\n```go\nfunc weightedRandomS4(weights []int) int {\n\tsort.Sort(sort.Reverse(sort.IntSlice(weights)))\n\trand.Seed(time.Now().UnixNano())\n\tr := rand.Intn(15)\n\tfor i, v := range weights {\n\t\tr = r - v\n\t\tif r <= 0 {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn len(weights) - 1\n}\n```\n\n可以通过数学期望来证明我们的想法。\n\n**最佳顺序**\n\n`{8, 4, 2, 1}`\n\nE = $\\frac{8}{15}$ $ \\times $1 + $\\frac{4}{15}$ $ \\times $2 + $\\frac{2}{15}$ $ \\times $3 + $\\frac{1}{15}$ $ \\times $4 = $\\frac{16}{10}$ \n\n**相对最佳顺序，较差的顺序**\n\n`{2, 4, 8, 1}`\n\nE = $\\frac{2}{15}$ $ \\times $1 + $\\frac{4}{15}$ $ \\times $2 + $\\frac{8}{15}$ $ \\times $3 + $\\frac{1}{15}$ $ \\times $4 = $\\frac{24}{10}$ \n\n**最差的顺序**\n\n`{1, 2, 4, 8}`\n\nE = $\\frac{1}{15}$ $ \\times $1 + $\\frac{2}{15}$ $ \\times $2 + $\\frac{4}{15}$ $ \\times $3 + $\\frac{8}{15}$ $ \\times $4 = $\\frac{32}{10}$ \n\n可以看到，最佳顺序，即权重从大到小的排序。\n\n### 方案五\n\n方案四中，实际上引入了一个新的耗时步骤，我们必须对 weightedRandom 排序，当这是一个很大的列表时，效率也就被拉低了。\n\n在方案五中，我们考虑使用累积权重，而不是原始权重。并且由于累积权重是升序排序的，我们可以使用二分来加快速度，因为二分查找可以将时间复杂度从 $ O(n) $ 变为 $ O(log(n)) $。\n\n```go\nfunc weightedRandomS5(weights []int) int {\n\trand.Seed(time.Now().UnixNano())\n\tsum := 0\n\tvar sumWeight []int\n\tfor _, v := range weights {\n\t\tsum += v\n\t\tsumWeight = append(sumWeight, sum)\n\t}\n\tr := rand.Intn(sum)\n\tidx := sort.SearchInts(sumWeight, r)\n\treturn weights[idx]\n}\n\n```\n\n### 方案六\n\n到目前位置，我们的解决方案已经足够好了，但是仍然有改进的余地。\n\n方案五中，我们使用了 go 标准库的二分查找算法 sort.SearchInts() ，它这是封装了通用的 sort.Search() 函数，如下。\n\n![sort.SearchInts](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E9%9A%8F%E6%9C%BA%E5%8A%A0%E6%9D%83/picture_01.png)\n\nsort.Search() 的函数参数需要一个闭包函数，并且这个闭包函数是在 for 循环中使用的，如下。\n\n![sort.Search](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E9%9A%8F%E6%9C%BA%E5%8A%A0%E6%9D%83/picture_02.png)\n\n所以目前无法被编译器正确地内联，从而导致了非实质性的性能开销，在方案六中，我们可以编写一个手动内联的版本。\n\n```go\nfunc weightedRandomS6(weights []int) int {\n\trand.Seed(time.Now().UnixNano())\n\tsum := 0\n\tvar sumWeight []int\n\tfor _, v := range weights {\n\t\tsum += v\n\t\tsumWeight = append(sumWeight, sum)\n\t}\n\tr := rand.Intn(sum)\n\tidx := searchInts(sumWeight, r)\n\treturn weights[idx]\n}\n\nfunc searchInts(a []int, x int) int {\n\ti, j := 0, len(a)\n\tfor i < j {\n\t\th := int(uint(i+j) >> 1)\n\t\tif a[h] < x {\n\t\t\ti = h + 1\n\t\t} else {\n\t\t\tj = h\n\t\t}\n\t}\n\treturn i\n}\n```\n\n通过基准测试可以看到吞吐量提升了 33% 以上。对于大型数据集，优势越明显。\n\n![优化前](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E9%9A%8F%E6%9C%BA%E5%8A%A0%E6%9D%83/picture_03.png)\n\n![优化后](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E9%9A%8F%E6%9C%BA%E5%8A%A0%E6%9D%83/picture_04.png)\n\n### 方案七\n\n目前为止我们所有的方案都有一个共同点 —— 生成一个介于 0 和权重之和之间的随机数，并找出它属于哪个“切片”。\n\n还有一种不同的方法。\n\n```go\nfunc weightedRandomS7(weights []float64) int {\n\tvar sum float64\n\tvar winner int\n\trand.Seed(time.Now().UnixNano())\n\tfor i, v := range weights {\n\t\tsum += v\n\t\tf := rand.Float64()\n\t\tif f*sum < v {\n\t\t\twinner = i\n\t\t}\n\t}\n\treturn winner\n}\n```\n\n这个算法的一个有趣的特性是你不需要提前知道权重的数量就可以使用它。所以说，它或许可以用于某种流。\n\n尽管这种方案很酷，但它比其他方案慢得多。相对于方案一，它也快了 25% 。\n\n## 源代码\n\n[https://github.com/guowei-gong/weighted-random](https://github.com/guowei-gong/weighted-random)"},{"title":"0秒改struct性能直接提升15%，产品姐姐都夸我好棒","tags":["Go"],"categories":"编程语言","author":"龚国玮","excerpt":"\n如果您以前写过 `Golang` ，那您很可能见过或者写过 `Struct` 结构体。但是，您可能不知道，通过简单地重新排序结构体中的字段，您可以极大地提高 Go 程序的速度和内存使用率！\n\n难以置","link":"/posts/change-struct-performace-directly","content":"\n如果您以前写过 `Golang` ，那您很可能见过或者写过 `Struct` 结构体。但是，您可能不知道，通过简单地重新排序结构体中的字段，您可以极大地提高 Go 程序的速度和内存使用率！\n\n难以置信吗？那让我们直接进入正题吧！让我们来看一个例子。如下。\n\n```go\ntype BadStruct struct {\n    age          uint8\n    IdCardNumber uint64\n    DateOfBirth  uint16\n}\n\ntype GoodStruct struct {\n    age          uint8\n    DateOfBirth  uint16\n    IdCardNumber uint64\n}\n```\n\n在上面的例子中，我们定义了两个具有相同字段的结构体。接下来让我们编写一个简单的程序来输出他们的内存使用情况。点击[此处](https://go.dev/play/p/DekLCtTGo6v)您可以获取测试代码。\n\n```\nBad struct is 24 bytes long\nGood struct is 16 bytes long\n```\n\n如您所见，它们占用的内存不同。\n\n到底发生了什么，导致两个字段相同的结构体消耗不同的字节？\n\n答案是数据在操作系统中的内存排列方式。换句话说，数据结构对齐。\n\n`CPU` 以字长的方式读取数据，而不是通过字节大小。64 位操作系统中一个字长为 8 个字节，而 32 位操作系统中一个字长为 4 个字节。换句话说，`CPU` 以字长的倍数读取地址。\n\n\n![](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/0%E7%A7%92%E6%94%B9struct%E6%80%A7%E8%83%BD/picture-01.png)\n\n在 64 位操作系统中，为了获取变量 `IdCardNumber`，我们的 `CPU` 需要两个周期来访问数据，而不是一个周期。\n\n第一个周期将获取到 0 到 7 的内存，其余周期获取其余部分。\n\n把它想象成一个笔记本，每页只能存储一个字大小的数据，此时是 8 个字节。如果 `IdCardNumber` 分散在两个页面上，则需要翻页两次才能检索完整的数据。\n\n**这是低效的。**\n\n因此我们需要对齐数据结构，即将数据存储在一个地址等于数据大小的倍数的位置。\n\n例如，一个 2 字节的数据可以存储在内存 0、2 或 4 中，而一个 4 字节的数据可以存储在内存 0、4 或 8 中。\n\n![](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/0%E7%A7%92%E6%94%B9struct%E6%80%A7%E8%83%BD/picture-02.png)\n\n通过简单的对齐数据，确保 `IdCardNumber` 可以在同一个 `CPU` 周期内检索到变量。\n\n填充是实现数据对齐的关键。操作系统在数据结构之间用额外的字节填充数据以对齐它们。这就是额外内存的来源！\n\n让我们再来看一看 `BadStruct` 和 `GoodStruct`。\n\n![](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/0%E7%A7%92%E6%94%B9struct%E6%80%A7%E8%83%BD/picture-03.png)\n\n`GoodStruct` 消耗更少的内存，仅仅是因为它比 `BadStruct` 有更好的结构体字段顺序。\n\n由于填充，两个数据结构分别变成了 16 字节和 24 字节。\n\n所以，您只需重新排序结构体中的字段，就可以节省额外的内存！\n\n最后，让我们来做一个简单你的基准测试来证明它在速度和内存的区别，结果如下。点击[此处](https://go.dev/play/p/i6F3VRFY61n)您可以获取可运行的代码。\n\n![](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/0%E7%A7%92%E6%94%B9struct%E6%80%A7%E8%83%BD/picture-04.png)\n\n从结果您可以看出，遍历 `GoodStruct` 花费的时间确实更少。重新排序结构体字段可以提高程序的内存使用率和速度。\n\n# 总结\n\n本篇博客带您了解了简单的数据对齐技术，**重新排序结构体中你的字段吧！** 数据结构的深思熟虑的对齐真的得到了回报。"},{"title":"CISC&RISC从哪里来，到哪里去","tags":[],"categories":"阅读航迹","author":"龚国玮","excerpt":"\n读历史方知进退，明兴衰。从石器时代到青铜器时代，再到铁器时代，都是工具种类和材料的发展，推动了文明升级。每个时代也有每个时代的产物。\n\n纵观计算机的发展史，理论到落地，创造了很多奇迹。\n\n19 世纪","link":"/posts/cisc-risc","content":"\n读历史方知进退，明兴衰。从石器时代到青铜器时代，再到铁器时代，都是工具种类和材料的发展，推动了文明升级。每个时代也有每个时代的产物。\n\n纵观计算机的发展史，理论到落地，创造了很多奇迹。\n\n19 世纪，英国数学家 Babbage 设计了分析机，现代电脑的结构几乎是它的翻版，无非是主要部件替换成了大规模集成电路。\n\n20 世纪初，图灵发表了论文《论可计算数及其在判定问题中的应用》，以最简单的方法抽象出统一的计算模型。\n\n1946 年，在美国宾夕法尼亚大学诞生了第一台真正意义上的电子计算机 ENIAC。它占地面积约 170 $m^2$，耗电量 150 kw。\n\n加点速，直接迈入芯片时代，芯片的定义是所有半导体元器件的统称，它是把一定数量的常用电子元件，以及这些元件之间的连线，通过半导体工艺集成在一起的、具有特定功能的电路。芯片相关的制造工艺（氧化、光刻、粒子注入等）极其复杂，是人类的制造极限。\n\n芯片中的特例 CPU，即中央处理器，是 Intel 在 1971 年将运算器和控制器集成在一个芯片上创作出来的产物，称为 4004 微处理器，后被广泛应用于个人计算机以及高性能服务器中。\n\n**CPU 的工作流程分为五个阶段：取指令、指令译码、执行指令、访存读取数据和结果写回**。\n\nCPU 运行程序会循环执行上述五个阶段，它既是程序指令的执行者，又被程序中相关的指令所驱动，最后实现了相关的计算功能。这些功能再组合成相应算法，然后由多种算法共同实现功能强大的软件。\n\nCPU 的工作离不开指令，指令离不开指令集架构，把指令看作`字`，指令集架构就是`新华字典`。\n\nCPU 的指令集越丰富、每个指令完成的功能越多，为该 CPU 编写程序就越简单，这就是复杂指令集计算机体系结构 —— CISC。CISC 的典型代表是 X86 体系架构。CISC 的优势在于，用少量的指令就能实现非常多的功能，程序自身大小也会下降，减少内存空间的占用。缺点就是，这些复杂指令集，包含的指令数量多而且功能复杂，这就导致了硬件工程师想要设计制造这样的电路，难度非常高。\n\n20 世纪 80 年代，芯片生产工艺的发展，CPU 上也实现了高速缓存、指令预取、分支预测、指令流水线等部件。不过，这些部件的加入引发了新问题，那些一次完成多个功能的复杂指令，执行的时候就变得捉襟见肘。\n\n例如一些串操作指令同时依赖多个寄存器和内存寻址，这导致分支预测和指令流水线无法工作。\n\n另外随着编译器技术的发展，各种高级编程语言开始盛行，它们生产的低级代码，比程序员手写的低级代码高效得多，使用的也是常用的几十条指令。\n\n这导致人们开始向 CISC 发展的反方向思考，我们需要精简指令集计算机体系结构，由此 RISC 诞生了。\n\n指令集被简化，这意味着简化了指令译码和执行指令，这使得 CPU 的新部件的效能得到了发挥。RISC 的代表产品是 ARM 和 RISC-V。\n\n今天，RISC 与 CISC 早已没有明显界限，比如 ARM 中假如了越来越多的指令，X86 通过译码器把一条指令翻译成多条内部微码，相当于精简指令。\n"},{"title":"套你猴子，如何设计一个数据库的索引模块","tags":["数据结构"],"categories":"数据库","author":"龚国玮","excerpt":"\n在数据库中，我们存储的通常是大量数据，因此没有办法一次把所有的数据都加载到内存中，从而利用内存的优势进行查询。那数据库是如何快速查询数据的呢？\n\n如果我们“全表扫描”，即遍历每一条记录逐一对比，查询","link":"/posts/design-an-index-module-for-db","content":"\n在数据库中，我们存储的通常是大量数据，因此没有办法一次把所有的数据都加载到内存中，从而利用内存的优势进行查询。那数据库是如何快速查询数据的呢？\n\n如果我们“全表扫描”，即遍历每一条记录逐一对比，查询速度肯定很慢。\n\n我们需要设计一种适合磁盘场景的特殊数据结构来提高查询速度，它应该满足对业务数据进行某种有序性的维护，可以结合内存，快速定位数据在磁盘中的位置，即“索引”。\n\n一般数据库实现索引，都使用非线性数据结构，例如树状类型。为什么不使用线性数据结构呢？\n\n因为在数据库场景中，我们随时都可能新增、修改数据，这涉及到数据移动，在磁盘上，这个代价是非常高的。而且线性数据结构存在平衡性，有利于查询的稳定性。非线性数据结构通常还支持检索某个范围内的数据，即范围查询。\n\n二叉查找树做数据库索引的数据结构怎么样？\n\n二叉查找树任意字段的查询一般只需要 log(n) 的复杂度，在百万级的数据存储场景，二叉查找树也只需要 20 层的高度就可以容纳全部数据。\n\n看起来还蛮不错嘛。不过在数据库中，除了考虑计算成本，还需要考虑因为磁盘的读取时间。如果我们的数据库采用二叉查找树储数据，数据一多，层级必然不会少，层与层之间的数据在物理介质上基本不连续，多次的跳转查询，对应读取多次磁盘，就算将前几层的数据预加载到内存中，仍然可能多次跳转查询，这非常致命，因为磁盘的读取时间远远大于数据处理时间。\n\n有没有什么数据结构，可以结合磁盘 I/O 的特性、保持树状结构的灵活呢？有！B+ 树。\n\n在 MySQL、PostgreSQL 索引的实现中，都能看见 B+ 树的身影。\n\nB+ 树由 B- 树演化而来，B 指的 balance 平衡。\n\n> B- 树，它的每个节点包含：\n> - 若干个键\n> - 若干个指针域。指针域指向真实的存储数据\n> \n> m 阶（m 代表树的每个节点做多可以包含的子节点数） B- 树的特性有：\n> - 所有叶节点处于同一高度\n> - 每个节点做多包含 m-1 个键和 m 条链\n> - 根节点不为叶子节点时，至少有两个子节点\n> - 除了根节点和叶子节点，每个节点最少包含 m/2 个键\n\n它的设计思想是，将相关数据尽量集中在一起，以便一次读取多个数据，减少磁盘的读取次数。也就是利用了磁盘访问的局部性原理。计算机在读取磁盘时，往往以`页`为单位，如果页的大小与 B 树节点存储大小一致，就可以做到一次读取整个节点的全部内容！以 MySQL 的 InnDB 为例，它通常采用 16 KB 大小的页，如果我们的索引字段的大小为 8 bit，B+ 树上的每个节点就能包含 2048 个键，这意味着用 4 层的高度，就可以查找接近 10 亿级别的数据。\n\nB+ 树的特点是：\n- 一个节点可以容纳多个值\n- 所有叶子节点之间都会通过双向指针串联在一起\n- 追求“层”越少越好。除非节点已经达到了树的最大子节点数\n- 中间节点不会存储指向真实数据的指针，只有叶子节点才存储，中间节点存储到达某叶子节点的路由信息\n- 子节点中的值，与父节点中的值有严格的大小关系。如果父节点有 a 个值，那么子节点就有 a+1 个子节点。假设现在父节点有 5、15 两个值，就对应 3 个子节点，第一个子节点都是小于 5 的值，最后一个子节点都是大于 15 的值，中间的子节点是 5 到 15 之间的值\n\nB+ 树相比 B- 树的优势就是在于高效的范围查询。假设我们查询所有年龄小于 35 岁的员工，我们只需要找到比 35 小的第一个元素，借助双向指针，就能快速获得所有小于 35 的元素。\n\n如果能让叶子节点指向的数据也能在磁盘上连续存储，肯定可以获得更好的查询能力，目前似乎没有什么太好的办法。"},{"title":"原神，启动！开放大世界登录系统设计","tags":["系统设计"],"categories":"游戏","author":"龚国玮","excerpt":"登录系统是基础性系统，和上层逻辑不一样，可以考虑消息驱动。\n\n## 热身阶段\n将游戏服务器结构分为上层逻辑层和基础组件层。不同游戏的区别在于逻辑层，玩法的不同。基础组件层，例如登录、DB 都可以实现为","link":"/posts/game-login-system","content":"登录系统是基础性系统，和上层逻辑不一样，可以考虑消息驱动。\n\n## 热身阶段\n将游戏服务器结构分为上层逻辑层和基础组件层。不同游戏的区别在于逻辑层，玩法的不同。基础组件层，例如登录、DB 都可以实现为通用的。\n\n随着游戏服务端的逻辑层越来越复杂，逻辑层也开始了分层。越来越复杂，首先得感谢外挂。国内的大部分游戏，对于使用外挂的玩家，处于放养的状态，基本上是不管的，如果逮到一个就封号，也不现实，假如一半的玩家都在用外挂，那么我把一半的玩家都封了，我的游戏也没办法运营了。因此国内的游戏服务端跟国外的服务端有一个重大的区别就是，国内的游戏的逻辑是跑在服务器上的，所有牵扯到玩家校验、财产的逻辑都是放在服务器上的。\n\n分层后，逻辑层增加了不同的场景服务器，目的是承载上万用户同时在线。服务端不像客户端，客户端就是玩的那个用户作为它的主要用户，客户端可以看到其他用户，但不会对它实际操作，而服务器是上万人都要操作。这是服务器相对于客户端的一个挑战。和登录相关的就是我们会拆非常多的进程，这些进程根据功能分为不同模块，有接入模块、逻辑模块、存储模块。这就导致了一个听起来非常简单的登录系统变为了一个大规模的分布式系统。\n\n## 什么是登录\n玩家通过客户端与服务器建立连接，在服务器各个进程上完成需要的账号和角色数据创建，并进入游戏场景开始游戏的过程。\n\n## 准备工作\n- 实现接入服务器\n- 实现 DB 存取\n- 制定协议\n\n## 登录的基本流程\n- 建立/断开连接\n- 用户登入/登出\n- 注册/注销/修改角色\n- 进入/离开场景（真的开始玩游戏了）\n\n建立/断开连接面向的主体是客户端和服务器，类似网络七层协议，而用户登入/登出面向的是用户。\n\n## 简单的登录流程\n简单的系统无法兼容复杂的系统，但是复杂的系统可以兼容简单的系统。当然，我们一开始做的时候肯定是从简单到复杂。\n\n![状态机](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1--%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/picture_01.png)\n\n- 分布式\n- 消息驱动\n- 多层状态机\n\n首先发起登录请求，然后从 DB 中将玩家数据 load 出来，进入一个 Login 状态机。玩家首先进入一个 Free 状态，从玩家的角度直观感受就是进入了选择角色的界面或者选择区服的界面，还没有进入场景。假如玩家就看一眼，就退出了，那么就清除它的上下文，退出状态机。如果继续玩，玩家就会进入了一个 Scene 的状态，进入这个状态后，玩家开始从 World 往 Scene 进程进，但是这就产生了一个异步的过程，我往 Scene 发消息，因为 Scene 是并发的，所以它不会阻塞式的立即回复发送的消息，它可能会把消息放到它处理的缓存池里，等它有能力处理这个消息的时候，才会返回结果。这就是为什么我们需要状态机，我们等消息来驱动，而不是客户端主动去轮询，这样的话服务器的负载就太高了。为什么 Scene 不能立即响应？假设 Scene 承载了某个场景，这个场景有多个地图，玩家进入这个场景后，需要创建这个 Scene 中地图的多个实例等数据，这个数据可能会非常大，因此我们不可能在玩家没有进入位面的时候，提前把所有玩家可能进入的位面都创建好，这样服务器完全扛不住，所以实际情况是，只有玩家实际进入某个位面的时候，我们才根据我们的负载均衡策略选择一个负载比较低的 Scene，来创建进入这个 Scene 需要的数据，创建这些数据是需要时间的，我们上层的状态机就需要等待 Scene 来创建这些数据的过程，即进入 Scene 状态。进入成功后，会进入一个 Game 状态，玩家开始在场景里玩游戏了，这个时候跟上层逻辑，也就是基础性系统的交互已经结束了，状态机就会一直处于 Game 状态。玩家不想玩了，下线后，客户端会发一个 Leave Scene 请求，告诉服务器，服务器处理完退出逻辑后，进入 Free 状态，因为玩家有可能想换个角色，进入了选角的界面，并没有真正的退出。真正的退出游戏后，状态机销毁，上下文销毁。\n\n可以看出，当我们搭建完一个登录系统后，一个最最简单的游戏服务器的框架就完成了。这个时候就是往 Game 状态下装游戏的玩法逻辑了。\n\n> 状态机是放在引擎层的，与玩法层隔离。假设我们把所有 Game 状态下的玩法逻辑都放到引擎层，或者说在 Scene 状态的时候，初始化一些玩家数据。那么不同项目要复用就不可能了。如果通过消息机制，那么我这套游戏的逻辑可以被其他游戏复用，不需要改太多逻辑。\n\n说了这么多，重点其实就是，我是一个状态机，有各种各样五花八门的消息来驱动我，我每个状态下可能还有各种分状态机。\n\n## 功能角度\n现代计算机，用穷举法破解你的口令可能会是一件很轻松的事。从开发者的角度来做设计口令这件事，应该考虑如下规则。\n- 限制玩家输入简单的口令。可以像 twitter 一样做一个口令的黑名单，也可以做一些简单的限制，例如是否有大小写字母、数字、符号等。这可能会让你的用户很不爽，所以现在很多登录都提供了 UX 让用户知道他的口令强度是怎么样的，目的就一个，告诉玩家，你的口令给我整复杂一点。\n![有趣的设计](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%E8%AE%BE%E8%AE%A1--%E7%99%BB%E5%BD%95%E7%B3%BB%E7%BB%9F/picture_02.png)\n> 在便池上放一个假苍蝇会导致男人撒尿的时候会不由自主地瞄准它，有证据表明，这样的用户体验可以减少80%的小便溅出便池。\n- DB 中不要明文保存玩家的口令。如果你的数据被你的不良员工流传出去那对用户是灾难性的。所以，用户的口令一定要加密保存，最好是用不可逆的加密，如MD5或是SHA1之类的有hash算法的不可逆的加密算法。\n- 正确的设计“记住密码”。对玩家来说是一件挺爽的事，但是时间一长，玩家可能就会忘记自己的口令，要考虑记住密码的过期时间。\n- 找回密码不要使用安全问答。这个环节很烦人，而且用户并不能很好的设置安全问答。例如我父亲姓什么，我最好的朋友是谁等等，因为今天的互联网和以前不一样了，今天的互联网比以前更真实了，我可能可以通过微博、LinkedIn等社交网站查询到你真实信息。\n\n## 性能问题\n在实际开发中，需要提前计算好每一个进程最多会用到多少内存，之前提到服务器跟客户端的区别，服务器会承载上万人同时在线，还有一个区别就是服务器是 24 小时在线跑的，客户端程序跑着跑着崩了，重启就行，但是服务器不行，重启后所有玩家都拉闸了。服务端崩掉，BUG、内存爆掉、断电、地震。因为游戏的开发模式是快速上线、迭代，因此出现 BUG ，进程宕掉是很正常的情况。\n\n服务器物理性能的边界：流量、CPU、内存、DB 访问。如果前面四个瓶颈被突破，那么不会有后面提到的两个问题：性能波动、毛刺与雪崩。性能波动，例如短期内大规模用户登录，如果不做平滑策略的话，来一个请求我就响应，CPU 可能就会被打满，引起雪崩，雪崩后，玩家就会变卡，变卡后玩家就会重新试，本来可能发了一次请求，现在变成了十次、二十次请求，积累的越来越多，处理量越来越大。平时通过计算内存的占用可以 Hold 住，但是一定要有应急策略，不能让 CPU 打满，雪崩就停服，因为这种原因停服我们就停职。\n\n## 总结\n登录系统，起到了一个奠定框架的作用。因为复杂性，游戏服务器逐渐从一个单体变为一个分布式系统。导致登录系统要在各个分布式的进程之间创建数据，同时在每个进程中产生了一个基础状态机的概念，在顶层也有一个状态机。我们还需要知道登录是个多层分布式状态机，对基本流程有印象，知道考虑常见的四个边界情况。还需要考虑性能、容灾问题，宕机后游戏还能恢复。"},{"title":"相比游戏客户端，游戏服务端开发无关紧要吗","tags":[],"categories":"游戏","author":"龚国玮","excerpt":"\n感觉游戏服务端，除了更新，保存数据啊、生成随机物品啊、都没什么了，好像游戏开发场景中，服务端已经无关紧要了。看着客户端忙成狗，正在摸鱼的你是否也有过这样的疑问？\n\n","link":"/posts/game-server-compared-game-client","content":"\n感觉游戏服务端，除了更新，保存数据啊、生成随机物品啊、都没什么了，好像游戏开发场景中，服务端已经无关紧要了。看着客户端忙成狗，正在摸鱼的你是否也有过这样的疑问？\n\n<!-- more -->\n\n## 为什么有游戏服务端\n因为有需求，我们需要解决需求。\n需求一：在家里的电脑打完这一关，去朋友家的电脑上玩，又要重新打一遍。有一个地方存储数据和关卡状态该多好。\n需求二：一直都是一个人玩，好希望和朋友一起玩啊。有中转的电脑，转发玩家的操作、状态就可以了。\n需求三：卧槽，这个人开挂，怎么一刀把我秒了，不公平，垃圾游戏，我不玩了。有校验玩家操作、反外挂、有裁判，维持公平和游戏性。\n\n从上面的三个需求，可以抽象出游戏服务器的功能应该有如下几点。\n- 网络服务\n    网络服务就是建立客户端与服务端之间的连接。\n- 玩家数据存取\n    最常见的就是登录，登录的时候需要取玩家数据。存，一般有三种存储方式，用户下线时写一次 DB。第二种是定时写回 DB。第三种是重要数据立即回写，例如玩家打到一个比较稀有的装备，就应该立刻保存，避免突然宕机导致数据丢失。\n- 游戏逻辑计算\n    逻辑计算，把以前单机时，前端的计算放到后端，这是为了防止作弊。\n- 玩家行为或状态变化的同步检测\n    这块可以理解成玩家可以看到他视野范围内看到什么东西。\n\n游戏服务器相比传统的互联网应用有如下特点。\n- 延迟敏感\n- 实时的高强度交互\n    一般单次请求就会产生复杂逻辑，还有一些广播和同步，比如移动同步，这就是一个很大的压力，假设你在一个二十人左右的场景里面，你发出了 5 个移动包，表示它移动的方向产生改变，目标点发生的改变，那么这个消息量将放大二十倍。\n- 业务逻辑复杂，内部耦合度高\n    因为延迟和敏感和高强度，那么在服务器维护状态就是一个必然的过程，这样就会导致它的逻辑比较复杂。比如你击杀一个怪物，可能它不仅仅是击杀一个怪物，还会触发一些任务的逻辑。\n- 变更频率高\n    游戏服务器的幅度一般没有传统的互联网应用幅度大。端游时代还好，但是现在是手游时代，基本上是一周一个小更新，一月一个大更新，所以服务器的灰度和部署需求也在逐渐变高。\n\n## 游戏模型发展史\n### 第一代游戏服务器\n![初代目](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_01.png)\n\n初代目的游戏服务器就是一个进程单线程物阻塞，接收到玩家的消息后，按照一个消息队列来进行序列化。这种游戏的代表就是 78 年的 MUD 游戏 Multiple User Domain，文字网游的统称，没有图形，通常是在终端与玩家交互，全部用文字和字符画来构成。\n\n![](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_02.png)\n\n### 第二代游戏服务器\n![第二代游戏服务](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_03.png)\n初代目由于承载能力的限制，衍生出了第二代游戏服务器，目的就是为了增加并发，开始使用了多线程多进程的模型，逻辑上也开始增加了分区分服的结构。代表作有《UItima》，中文名叫《创世纪》。\n\n![UItima](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_04.png)\n\n2000年，联众的休闲棋牌。\n\n![联众的休闲棋牌](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_05.png)\n\n> 在 2003 年年底，联众游戏世界的注册用户一度超过2亿，月活用户达1500万，中国网络棋牌游戏的绝对霸主，但是 2003 年下半年，腾讯公测 QQ 游戏大厅，功能与游戏门类与联众大同小异，QQ 游戏大厅不同在于，每次你的 QQ 好友在游戏大厅玩游戏时，他的头像下方就会显示他正在玩什么游戏，这个状态栏一点开，你就能跟他一起玩了，就这么一点小细节，让联众游戏世界和 QQ 游戏大厅的用户流量在一两年里发生了戏剧性的此消彼长。2006年，彻底败北的联众创始人辞职，之后他成为投资人，坚持只做腾讯不做的项目。\n\n### 第三代游戏服务器 - 三层架构\n![三层架构](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_06.png)\n\n第三代游戏服务器就比较百花齐放了，首先就是当时流行的三层架构，抽出 Gate Server 的部分去负责网络 IO 连接的部分，然后 Gate Server 通过一个内部的网络 IDC 的专网跟游戏逻辑服务器之间交互，最后把用户数据的存储放到 DB Server 这一层。\n总的来说，三层架构它的主要特点就是把网络 IO 和存储跟逻辑分离，这样可以对每一层进行扩展，增加服务的承载能力。QQ 游戏大厅就是比较典型的代表。\n\n![QQ 游戏大厅](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_07.png)\n\n### 第三代游戏服务器 - 服务器集群\n![服务器集群](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_08.png)\n\n这种架构前面同样也是有 Gate Server 这种接入型服务来处理外网连接，然后在游戏 world 里去处理游戏逻辑。它与三层架构不同的是，它会把通用逻辑抽取出来，例如登录、聊天、组队、工会等，放在独立的位置，通过 cluster 集群的方式提供这种游戏服务，调用者通过调用函数来获取对应的功能。大部分的 MMO-RPG（MMO：Massive Multiplayer Online，大型多人在线游戏） 、RPG（Role Playing Game：角色扮演） 游戏都是这种结构。\n这种方式，中间肯定就多了一些异步的交互，异步交互就会带来状态维护的问题，开发难度也随之提高。代表游戏有《地下城与勇士》。\n\n![地下城与勇士](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_09.png)\n\n### 第三代游戏服务器 - 无缝地图\n\n![无缝地图](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_10.png)\n\n这个类型的游戏，最大的代表游戏就是《魔兽世界》，相比以前的《传奇》类型的游戏，它切换地图的时候，客户端会明显的卡顿或者进入 loading 界面。无缝地图的特点就是玩家在游戏中移动时，会看到地图一直都在不停的加载，因为它的场景服务器只负责一部分场景，玩家移动到某个地方时，场景可能存在两个场景服务器上。这些场景服务器会由一个更高层的服务器来决策由哪台服务器加载场景。\n\n![魔兽世界](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_11.png)\n\n### 第三代游戏服务器 - 房间型\n\n比较常见的游戏类型都会使用这种模型。它通常有一个大厅集群，它通常负责前面提到的 Gate Server 用户的接入，还有一些大厅的逻辑服务，例如 5V5 匹配，有多个玩家申请进游戏的时候，它会根据匹配规则，等级啊，玩家的技术啊来撮合两个队伍。然后，单局的过程会放到战斗集群，也叫做房间服务。代表游戏有腾讯的《英雄联盟》，《英雄联盟》把电竞行业也推到了一个前所未有的高度，想到以前高中和兄弟们一起开黑，真是快乐。\n\n![英雄联盟](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_12.png)\n\n## 核心技术和实现难点\n游戏服务器技术跟客户端比较，客户端主要在用户交互和体验表现方面。而服务器则是要面对海量用户，十万到千万的 PCU，PUC 是游戏里面，用户数据的一个指标，Peak Concurrent Users 最高同时在线玩家人数，还有 DAU Daily Active User 每天登录过的用户，PCU 比较考量服务器的性能数据，DAU 更倾向运营数据。\n\n稳定，服务器玩的时候不能宕机，还有就是容忍一些弱网络的问题，网络断了，允许他在短时间内 WIFI - 4G 的切换。\n\n地图&视野同步，地图服务功能，服务器最常用的是九宫格技术，一块九宫格的内容，玩家在其中格，这个格往往比屏幕大一点，会收到这个格里面的内容，一般服务器会认为你在这个九宫格内，所有的玩家、怪物等都是你关注的对象，当你在一个格内移动时，视野是不会发生变化的，但假设移动跨格后，那么就认为玩家放弃了上一个九格宫中关注的内容，在客户端将不可见上一个格子中的内容，在服务器角度仍然可见。目的就是用户在移动的过程中比较平滑的加载数据，减少交互的数量。地图管理还包括一些动态阻挡，比如两个人走到同一个点，能够挤在一起还是重叠。还有就是静态阻挡，一个物件放置在那里，服务器要判断玩家能否走过去。移动中，主要问题还在延迟、拉扯、平滑、差值。\n\n最后游戏中非业务的难点还有存储、缓存、反外挂、网络协议等。我根据目前我的技术栈来列举。如下。\n\n![Go游戏开发技术栈](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E6%B8%B8%E6%88%8F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%B7%A5%E4%BD%9C/picture_13.png)"},{"title":"枯燥且重要，网络体系结构","tags":["网络体系结构"],"categories":"计算机网络","author":"龚国玮","excerpt":"\n - 为什么设计分层网络模型？\n - 两个模型各有多少层？\n - 模型中每一层的作用和顺序关系？\n - 两个模型的差异点和共同点？\n\n ","link":"/posts/get-start-with-network-architecture","content":"\n - 为什么设计分层网络模型？\n - 两个模型各有多少层？\n - 模型中每一层的作用和顺序关系？\n - 两个模型的差异点和共同点？\n\n <!-- more -->\n\n## 常见的计算机网络体系结构\n为了让世界各地的计算机互连，在 1977 年，成立了国际化组织研究该问题。在 20 世纪 90 年代初期，该组织就推出了“开放系统互连参考模型”，简称 OSI 体系结构，作为该问题的解决方案。\n### OSI 体系结构\n该模型是一个 7 层体系结构，从下往上依次是物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。\n\n![][1]\n\nOSI 模型是国际化组织推出的国际标准，但当时因特网的网络体系结构 TCP/IP 体系结构，已抢先在全世界覆盖了相当大的范围。\n### TCP/IP 体系结构\n该模型是一个 4 层体系结构，从下往上依次是网络接口层、网际层、运输层和应用层。\n\n![][2]\n\n在过去，制定标准的组织中，往往以专家和学者为主。但现在，许多商业公司也加入了制定标准的队伍中。TCP/IP 体系结构是事实上的国际标准，它占领了市场，而 OSI 体系结构是法律上的国际标准。\n由于 TCP/IP 体系结构为了兼容不同的网络接口进行互连，例如 WIFI 接入或以太网接入，因此它的网络接口层并没有规定什么具体的内容，然而这对于学习计算机网络的完整体系而言，就会缺少一部分内容，所以在学习计算机网络体系结构时，往往使用 OSI 体系结构和 TCP/IP 体系结构的一种综合体系结构：原理体系结构。\n### 原理体系结构\n该模型是一个 5 层体系结构，从下往上依次是物理层、数据链路层、网络层、传输层和应用层。\n\n![][3]\n\n## 计算机网络体系结构分层的必要性\n先来看最简单的情况，两台计算机如何连接起来？连接起来要解决 3 个问题，如下。\n - 采用怎样的传输介质？例如网线\n - 采用怎样的物理接口？例如电脑上的水晶头接口\n - 使用怎样的信号表示比特 0 和 1 ？例如方波信号\n这些问题可以归类到第 1 层，物理层。\n实用的计算机网络，往往由多台计算机组成，例如主机 A、B、C、D、E，通过总线互连，构成了一个总线型网络。\n\n![][4]\n\n假设我们解决了物理层的问题，也就是说主机间可以发送信号传输比特 0 或 1 了，现在我们要从主机 A 传输信号到主机 C，但是，表示数据的信号会通过总线传播到总线上的每一个主机，那么问题来了，主机 C 如何知道该数据是发送给自己的，自己要接收处理？而主机 B、D、E 如何知道该数据并不是发送给自己的，自己应该如何拒绝？这就引出了如何标识网络中各主机的问题，也就是编址问题。我们的计算机网卡上，存在一个 Mac 地址，这就解决了编址问题，通过发送地址和目标地址，就可以知道数据是谁发给谁的了。\n现在又出现了一个问题，如何从信号所表示的一连串比特流中区分出数据和地址？也就是数据格式问题，又成为分组问题。\n还有一个问题，假设主机 B 和 主机 D 同时向总线发送数据，这必然会发生信号碰撞，如何协调主机争用总线？总线型网络现在已经淘汰，现在常用的是使用以太网交换机，将多台主机互连，形成交换式以太网。通过交换机解决主机争用总线的问题。\n\n![][5]\n\n我们将下面提到的 3 个问题：\n - 如何标识网络中的各主机？\n - 如何从信号所表示的一连串比特流中区分出数据和地址？\n - 如何协调各主机争用总线？\n\n归类到第 2 层，数据链路层。\n我们可以发现，只要解决了物理层和数据链路层的问题，我们就可以数据在一个网络上传输了，但是，我们每天使用的因特网，是由非常多的网络组成的，仅解决物理层和数据链路层的问题，还是不能正常工作。来看下面的例子，这是一个由 4 个网络组成的小型互联网，我们可以把它看做因特网中很小的一部分。\n\n![][6]\n\n在之前的例子中，仅有一个网络，我们不需要对网络进行标识，在本例中，我们有着多个网络和多个主机，换句话说，我们面临了一个新的问题，网络和主机的编址问题，相信你一定听过 IP 地址，例如现在，192.168.1.1、192.168.1.2 和 192.168.1.254 是网络 N1 中各设备的 IP 地址。\n\n![][7]\n\n该 IP 地址的前三个十进制数，用来标识网络，第四个十进制数，用来标识主机，在本例中，用 192.168.1 标识网络，该网络上的笔记本电脑、服务器和路由器接口的前三个十进制数，都应该是 192.168.1 ，因为它们都在网络 N1 上，而第四个十进制数分别为 1、2 和 254，各不相同，用来标识它们自己。网络 N2、N3 和 N4 同理。\n我们再来看另一个问题，源主机与目的主机之间的传输路径往往不止一条，分组从源主机到目的主机可走不同路径，这样就引出了路由器如何转发分组，如何进行路由选择的问题。\n\n我们将下面的问题：\n - 如何标识各网络以及网络中的各主机？\n - 路由器如何转发分组？\n - 路由器如何进行路由选择？\n\n归类到第 3 层，网络层。\n至此，我们解决了物理层、数据链路层和网络层各自的问题，不过，这对于计算机网络应用而言仍然不够，假如我们的笔记本中运行着两个与网络通信相关的应用进程，浏览器进程和 QQ 进程，某个时刻，笔记本收到了来自主机的分组，应该交给哪个进程处理呢？也就是如何解决进程之间基于网络的通信问题。\n\n![][8]\n\n另外，出现传输错误时，如何处理？例如路由器繁忙，出现了丢包。\n我们将如下问题：\n - 如何解决进程之间基于网络的通信问题？\n - 出现传输错误时，如何处理？\n\n归类到第 4 层，传输层。\n\n解决了物理层、数据链路层、网络层和传输层各自的问题的基础上，我们只需要按协议标准编写相应的应用程序，通过应用进程间的交互，来完成特定的网络应用即可，例如，支持万维网应用的 HTTP 协议、支持电子邮件的 SMTP 协议和支持文件传输的 FTP 协议。\n我们将通过应用进程间交互完成特定的网络应用，归类到应用层。\n至此，我们已经了解了计算机体系结构中各层要解决的问题，这些问题分别划归到了物理层、数据链路层、网络层、传输层和应用层。如下。\n - 物理层：解决使用何种信号来传输比特的问题\n - 数据链路层：解决分组在一个网络上传输的问题\n - 网络层：解决分组在多个网络上传输的问题\n - 运输层：解决进程之间基于网络通信的问题\n - 应用层：解决通过应用进程的交互来实现特定网络应用的问题\n\n  [1]: https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B0%E6%89%8B%E6%9D%91/OSI%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\n  [2]: https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B0%E6%89%8B%E6%9D%91/TCP%3AIP%20%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\n  [3]: https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B0%E6%89%8B%E6%9D%91/%E5%8E%9F%E7%90%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png\n  [4]: https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B0%E6%89%8B%E6%9D%91/%E5%88%86%E5%B1%82%E5%BF%85%E8%A6%81%E6%80%A7-1.png\n  [5]: https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B0%E6%89%8B%E6%9D%91/%E5%88%86%E5%B1%82%E5%BF%85%E8%A6%81%E6%80%A7-2.png\n  [6]: https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B0%E6%89%8B%E6%9D%91/%E5%88%86%E5%B1%82%E5%BF%85%E8%A6%81%E6%80%A7-3.png\n  [7]: https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B0%E6%89%8B%E6%9D%91/%E5%88%86%E5%B1%82%E5%BF%85%E8%A6%81%E6%80%A7-4.png\n  [8]: https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%96%B0%E6%89%8B%E6%9D%91/%E5%88%86%E5%B1%82%E5%BF%85%E8%A6%81%E6%80%A7-5.png"},{"title":"掀起你的盖头来，让我看看HTTP的内容协商","tags":["HTTP","应用层"],"categories":"计算机网络","author":"龚国玮","excerpt":"\n## 数据类型与编码\n\nHTTP 协议必须要告诉上层应用，传输的是什么数据类型，否则上层应用只能“猜”传输的数据是什么类型。\n\nHTTP 协议通过 Multipurpose Internet Mai","link":"/posts/http-content-negotiation","content":"\n## 数据类型与编码\n\nHTTP 协议必须要告诉上层应用，传输的是什么数据类型，否则上层应用只能“猜”传输的数据是什么类型。\n\nHTTP 协议通过 Multipurpose Internet Mail Extensions，多用途互联网邮件扩展，简称 MIME，来做这件事。\n\nMIME 把数据归类到八大类，每个大类下又细分了子类，形式是 `type/subtype` 的字符串，常见的有：\n- image/gif，图像文件；\n- text/html，表示了超文本文档；\n- application/json，数据格式不确定，必须由上层应用程序来解释。\n\nHTTP 在传输时为了节约带宽，有时还会压缩数据，为了不让上层应用继续“猜”，还需要有一个 Encoding Type，告诉上层应用，数据是用的什么编码格式，这样对方才能正确解压缩，得到原始的数据。\n\n比起 MIME Type 来说，Encoding type 就少了很多，常用的只有三种：gzip、deflate、br。\n\n### 数据类型与编码使用的头字段\n\nHTTP 协议通过两个 Accept 请求头字段和两个 Content 实体头字段，来标记 MIME Type 和 Encoding Type，完成客户端和服务器的**内容协商**。\n\n客户端用 Accept 字段，告诉服务器希望接收的数据，服务器用 Content 字段，告诉客户端实际发送的数据。\n\nAccept 字段标记值，可以用 `,` 做分隔符，列出多个类型，让服务器有更多选择的余地，例如：\n\n`Accept: text/html,application/xml`\n\n这就是告诉服务器：我能够看懂 HTML、XML 的文本，可以给我这两类格式的数据。\n\n相应的，服务器会在响应报文里，用 Content-Type 字段告诉客户端，实际发送的数据是什么类型，例如：\n\n`Content-Type: text/html`\n\nAccept-Encoding 和 Content-Ecoding 字段可以忽略，Accept-Encoding 字段标记的是客户端支持的压缩格式，同样也可以用`,`列出多个，服务器可以选择其中一种来压缩数据，实际使用的压缩格式放在响应头字段 Content-Encoding 里。\n\n## 语言类型与编码\n\nMIME type 和 Encoding type 解决了计算机理解数据的问题，但不同国家的人使用了不同的语言，虽然都是 text/html，但如何让浏览器显示出每个人都可阅读的自然语言？\n\nHTTP 采用了与数据类型相似的解决方案，又引入了两个概念：语言类型与字符集。\n\n所谓的`语言类型`就是人类使用的自然语言，例如：英语、汉语、日语等，而这些自然语言可能还有下属的地区性方言，使用`type-subtype`的形式表示，例如：en 表示任意的英语，en-US 表示美式英语，en-GB 表示英式英语。\n\n关于自然语言，还有一个东西，叫`字符集`。在计算机发展的早期，各个国家发明了不同的字符编码方式来处理文字，比如英语使用 ASCII，汉语使用 GBK。同样的一段文字，用一种编码显示正常，换另一种编码后就乱码。\n\n后来就出现了 Unicode 和 UTF-8，把世界上所有的语言都容纳在一种编码方案里。\n\n### 语言类型与编码使用的头字段\nAccept-Language 字段，标记客户端可理解的自然语言，用`,`做分隔符列出多个类型，例如：\n\n`Accept-Language: zh-CN, zh, en`\n\n这个请求头会告诉服务器：最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文。\n\n字符集在 HTTP 里使用的请求头字段是 Accept-Charset，服务器响应放在 Content-Type 字段，用`charset=xxx`来表示，例如：\n```\nAccept-Charset: gbk, utf-8\n\nContent-Type: text/html; charset=utf-8\n```\n## 协商内容的质量值\n\n在 HTTP 协议里用 Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用`q`参数表示权重来设定优先级，这里的 `q` 是 Quality Factor 的意思。\n\n权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝。\n\n表现形式是在数据类型或语言代码后面加一个`;`，然后是 `q=value`。在 HTTP 的内容协商里，`;` 的意断句语气小于 `,`，例如：\n\n`Accept: text/html,application/xml;q=0.9,\\*/\\*;q=0.8`\n\n它表示浏览器最希望使用的是 HTML 文件，权重是 1，其次是 XML 文件，权重是 0.9，最后是任意数据类型，权重是 0.8。服务器收到请求头后，就会计算权重，再根据自己的实际情况优先输出 HTML 或者 XML。\n\n### 内容协商的结果\n\nVary 字段，记录服务器在内容协商时参考的请求头字段，例如：\n\n`Vary: Accept-Encoding,User-Agent,Accept`\n\n表示服务器依据了 Accept-Encoding、User-Agent 和 Accept 这三个头字段，然后决定了发回的响应报文。\n\n每当 Accept 等请求头变化时，Vary 也会随着响应报文一起变化。也就是说，同一个 URI 可能会有多个不同的“版本”，主要用在传输链路中间的代理服务器实现缓存服务。\n"},{"title":"观察性能指标“平均负载”","tags":["平均负载"],"categories":"Unix","author":"龚国玮","excerpt":"\n发现系统变慢时，我们可以通过 top 或 uptime 命令，了解系统负载情况，如下。\n```shell\n$ watch -d uptime\n02:34:03 up 2 days, 20:14,  ","link":"/posts/load-average","content":"\n发现系统变慢时，我们可以通过 top 或 uptime 命令，了解系统负载情况，如下。\n```shell\n$ watch -d uptime\n02:34:03 up 2 days, 20:14,  1 user,  load average: 0.63, 0.83, 0.88\n```\nWatch -d 可以高亮显示变化的值，输出值含义如下。\n```\n02:34:03 \t\t\t\t\t   // 当前系统时间\nup 2 days, 20:14 \t\t\t   // 系统运行时间\n1 user \t\t\t\t\t\t   // 正在登陆用户数\nload average: 0.63, 0.83, 0.88 // 过去 1分钟、5分钟、15分钟的平均负载\n```\n前面 3 个输出值很好理解，重点解释，什么是平均负载。平均负载是指单位时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数。\n- 可运行状态进程：处于运行队列中的进程，使用 ps 命令，看到处于 R （Running 或 Runnable）状态的进程，正在等待 CPU 资源\n- 不可中断状态进程：处于等待 I/O 操作完成的进程，例如磁盘读写操作，使用 ps 命令，看到处于 D （Disk Sleep）状态的进程\n平均进程数的平均，是一个统计学意义上的平均值，统计方法为 EWMA 加权移动平均，这里不展开介绍。\n平均负载的值，最理想的情况是每个 CPU 上都刚好运行了一个进程，例如平均负载为 2。\n- 2 个 CPU 的系统上，意味着所有 CPU 都刚好被占用，理想状态\n- 4 个 CPU 的系统上，意味着 CPU 有 50% 处于空闲状态\n- 1 个 CPU 的系统上，意味着有一半的进程竞争不到 CPU\n```shell\n$ grep 'model name' /proc/cpuinfo | wc -l // 获取 CPU 核数\n```\nCPU 使用率和平均负载不能划上等号。例如 I/O 密集型进程，等待 I/O 会导致平均负载很高，但 CPU 使用率不一定很高。\n在 ubuntu 上，可以通过 sysstat 监控和分析系统的性能。\n```\n$ apt install sysstat\n```\n如果是普通用户登录，先切换到 root 用户。\n```\n$ sudo su root\n```\nSysstat 包的 mpstat 和 pidstat 命令，可以用来分析每个 CPU 的性能指标和进程的 CPU、内存、I/O 等性能指标。下面列举几个使用场景。\n- CPU 密集型进程\n```shell\n# -P ALL 表示监控所有CPU，后面数字5表示间隔5秒后输出一组数据\n$ mpstat -P ALL 5\n```\n```shell\n# 间隔5秒后输出一组数据\n$ pidstat -u 5 1\n13:37:07      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command\n13:37:12        0      2962  100.00    0.00    0.00    0.00  100.00     1  stress\n```\n- I/O 密集型进程\n```shell\n# 显示所有CPU的指标，并在间隔5秒输出一组数据\n$ mpstat -P ALL 5 1\n```\n- 大量进程的场景\n```shell\n# 间隔5秒后输出一组数据\n$ pidstat -u 5 1\n```\n小结如下。\n- 平均负载一定要结合 CPU 核数来观察。\n- CPU 使用率和平均负载不能划上等号。\n- 1、5、15 分钟的值，可以分析出平均负载的变化趋势。\n- 平均负载高于 CPU 数量 70% 的时候，就应该分析排查负载高的原因。\n"},{"title":"你以为你错过的是一个人，其实你错过的是整个人生","tags":[],"categories":"朝花夕拾","author":"龚国玮","excerpt":"\n嗯…对…我的表白失败了…写这段话的时候，已经晚上2点了，外面刚刚下完一场大雨，外面安静的要死。我翻来覆去睡不着，最近升温了，我开了空调，我还是决定趁着夜深人静把发生的事情记录下来，我怕一觉睡醒，我的","link":"/posts/missing-out-on-a-whole-life","content":"\n嗯…对…我的表白失败了…写这段话的时候，已经晚上2点了，外面刚刚下完一场大雨，外面安静的要死。我翻来覆去睡不着，最近升温了，我开了空调，我还是决定趁着夜深人静把发生的事情记录下来，我怕一觉睡醒，我的情绪就淡化了。虽然我表白失败了…但还是想跟大家讲一下过程，我觉得过程比结果重要，6月7号第一考，语文，作为文科生的男同学，这自然是我最拿手的一门课，全卷做下来，还可以，感觉良好，每年的高考作文都是重头戏嘛，而我当时面临的题目是，教员在《新青年》发表的《体育之研究》一文。考前我们老师一再强调，考完不要去对答案，忘掉就好，准备下一门。我也难的克制住了那一股想跟她交流的念头，我怕影响到她，所以就没有去找她。\n\n直到下午考完，当天考试结束，我才给她发了消息，问她考的怎么样，她说：“感觉还可以，应该没什么大问题”。我不敢说太多，怕祸从口出，影响到我跟她剩下的几场考试。那几天嘛，精神高度集中，就好像全中国所有人都在为我们让路，这就是祖国的花朵的待遇嘛！直到那最后一张试卷检查完了最后一遍，精神重于松懈了，结束了。把笔放下响铃收卷那一刻，我十八岁的青春，就用一支笔，几张试卷，寥寥草草的画上句号了。那种如释重负的感觉，就好像在说，这三年过得太快了，这就结束了。\n\n当天晚上，班主任说要请我们班所有同学一起吃顿饭，而且，允许喝酒，他请客！随后我面临一个非常严峻的问题。我应该怎么告诉她，我喜欢她呢。那天晚上吃饭的时候，大家都特别开心。如果，抛开毕业典礼不谈，那天应该是我高中生涯的最后一天，也是我整个高中最快乐的一天。酒精是个坏东西，它能让人不自觉的笑，也能让人不自觉的哭，人一旦放纵起来，自己都不知道自己干的是什么事。我最好的朋友，屈哥喝多了拿着酒杯走到我的面前问我：“兄弟，你爱我嘛？你如果爱我！你就再跟我喝一杯酒。”当时在场的人都笑了，她也笑了。我真拿屈哥没办法就倒了一杯酒，起身准备跟他干一杯，屈哥又拦住我说：“兄弟！我们怎么能那么庸俗呢？真男人，就得喝交杯！”那我也拿屈哥也没办法，能咋的，宠着呗，至少大家看到都开心了，她也开心了，她开心我就开心了。后来趁着酒意，我就坐到了她身边，我就问她：“要不…你往我衣服上签个名吧？留个纪念！”她说：“好啊，那你也给我签一个。”我听到之后特别开心，至少我们也穿了三年的情侣服了，对吧。那一天真的是我整个高中最快乐的一天，那天晚上大家畅谈理想，聊未来，聊现在，有人趁着夜色和酒意表白，而那个被表白的姑娘也冲着那个鲁莽的男生点了点头。我并没有选择在那天晚上跟她表达心意，我有我自己的计划。那天晚上回去之后，过了凌晨十二点，突然开始下大雨。而我坐在书桌前，写着一封信。是的，我给她写了一封信，手写信！老子第一次给人写手写信！写了好久，也改了好久，当时我有感觉，她可能会拒绝我，但我还是很认真的写完了。我不是非要跟他在一起，而是我喜欢她这件事情，我想跟她说而已。\n\n第二天，我约她出来吃东西，雨过天晴，新鲜的空气，我还买了一本书，毛姆的《面纱》，把我写的信夹在书里。我递给她的时候，她一脸吃惊，问我为什么要送给她一本书，我说，想送就送咯。她拿到之后，翻了几页就合上了。我们在夕阳下山前，做了告别。其实我有提出要主动送她回家的，但是她拒绝了。那么接下来给大家读一下我的表白信吧，献丑了！\n\n## 表白信\n\n很抱歉，这封信没有对你的尊称，因为我会亲手把信送到你的手里，我不用舒心的传统格式，正如我想对你说的话，就像这封夹在书里的信，你只要不去翻看，就永远不会知情。我知道你会看的，你总是这样细心。我认识你比你认识我早一点，当初看到你的第一眼就比你吸引，想认识你。\n\n高一跟在你的身后，在倒数第二排看你，高二侥幸又在一起，那天问你的作文题，其实类似的题目我写了三遍有余，在台上你穿着白裙，台下我咬着牙，想让那个男主持人跟你再保持一点距离。谢谢你那天愿意跟我吃泡面，不然的话我可能会尴尬到颜面扫地。你说你喜欢张爱玲，而我喜欢顾城，但那个时候我知识匮乏，只读了作品，我不知道，顾城是一个杀人犯，张爱玲到最后都是个孤寂人。记得曾经跟你一起看过云，引用一首顾城的诗，你，一会儿看我，一会儿看云，我觉得，你看我时很远，你看云时很近，我在看你的时候，你还在看云。我数次觉得我在仰望你，时至今日，我还是觉得我们之前存在着距离。但是我转念一想，人和人之间，本来就该保持距离，我超越过你一，那次我真的很开心，不是因为成绩，而是因为你对我说，“君今日，令我刮目相看”的这句话语。我应该谢谢你，主观来讲，你就是我学习的动力。我抬头望你，仿若申明低语。你总是能说一些，能让我立马掏出本子记下来的话语，我至今为止都记得“实际上正因为那是爱，才会让我们如此失望。”还有那一句“爱，就是保持距离。”我对这句话有一点自己的看法，我觉得“爱是在靠近之后，主动保持距离。”我觉得人得承认自己的无知吧，我确实在诸多方面都配不上你，我翻山越岭，终极目标就是想跟你并排走，想靠近你。写下这些文字的此刻，外面正下着雨。也不知道为何，好像每年高考完，都要下一场大雨。我倾尽我三年之所想，都写在这封信里，我喜欢你，此乃勇气之举，整整三年，早已做好充足准备，不必感到为难，也不必如我所愿，你看到这里的时候，话基本说尽了。此举只是为了不留遗憾，做青春之告别。从初见至此刻，已想数日，等待许久，多有打扰，期待回信。\n\n这就是我写给她的表白信了，虽然就这么一点文字，但是真的写了又改，改了又写。一直在等她回消息，感觉时间特别慢，我实在忍不住了我就问她，你看了吗？她还是没有回我，有想给她打电话的冲动，但被我克制住了。我妈喊我下楼吃饭，我就匆匆忙忙的跑下楼，匆匆忙忙的扒完饭，再匆匆忙忙的跑上楼，打开手机一看，还是没有消息。当时有点失望，就躺上床闭眼睡觉了，突然噔噔噔，一声微信响了，我匆忙打开微信，没有文字，是一张照片，照片里是一封回信，写给我的回信，是这样写的。\n\n## 回信\n\n其实你把书塞到我手里的时候，我就看到了中间有缝隙，多半是塞了东西，我到家第一时间就看了，写的不错，有进步，但说实话，你想表达的东西，在我意料之外，但确实也在情理之中。刚开始看到的时候确实有很多话想要说，但写这封回信的时候，已经不知道说什么了。看到的时候想了很多，该如何答复你，你想表达的东西，我都知道，心领神会，只是可惜，就如张爱玲那句话，生命是一袭华美的袍，爬满了虱子，而青春的告别也总是充满了遗憾，你当了我两年的朋友，你应该知道我在想什么，我理应拒绝你，我知道我对你是什么感觉，而你对我是那种可以说很多话的朋友，但朋友始终是朋友，其实有些话不说破，我们还可以相处很久很久。只是可惜，事已至此，无可奈何。我尊重你的表达，但是我能说的也就到这里为止了。身体有恙的话，就多锻炼，按时吃三餐，照顾好自己的身体。望别日君卿相见时，君，已有所成。\n\n唉，被拒绝了，有点可惜，其实表白前就有人跟我说，就算成功了，也会面临异地上学的问题。如果失败了，那就真的连朋友都做不成。谁会甘心做所谓的朋友呢。我想了很久该回她什么，最终回了三个字：“知道了”。她秒回，“嗯”。我把手机关机了，风扇还在转，关灯，拉窗帘，窗外的天空还有一点暗蓝色的余光，我他妈地突然觉得有点难过，但是我哭不出来。于是我拿起了眼药水，往眼睛里，滴了几滴，随后，一滴伪装的“泪水”，从眼角，滑落至耳根，我闭上了眼睛，闭了很久。那些一直没有开口的告别，最终还是让她听见了。可能自始至终属于她身上的那些优秀的光环，都在彰显着，我和你的距离，我一步一步的靠近她，直到我也获得了属于我身上的光环才发现，每个人都有自己的弊端，她也并不是我想象那么的完美无暇，而我们之间的距离，就是我在看她，她在看着云的距离。你们要问我后悔吗，我觉得我不后悔，那些话就是我想说的话，之前我就说了，我不希望我想表达的东西，就这样掩与唇齿，止于岁月。也许就跟她说的一样，生命是一袭华美的袍，爬满了虱子，而青春的告别也总是充满了遗憾。\n\n难过是真的不难过，可惜是真的可惜。我失去的不仅是我喜欢的人，还有一个就是可以畅谈人生理想，说真话的朋友。但说实话，我还是有点难过的，失落居多吧，尽管我早就想过，有可能会被你拒绝的。我始终觉得，喜欢，是一个人的事，我说了我想说的，你也做了你能做的，到此为止，可以了。\n\n说实话，我脑子里，现在又蹦出一个想去找你的念头，但我好像没有勇气了。祝我们，别日相见时，都已有所成。我永远不会忘记在我21岁那年，结束了我与一个幻影的追逐，这个幻影会停留在我的21岁，但是我的生命永远不止21岁。\n\n卿本良人，奈何缘尽。"},{"title":"谁的小霸王？多人游戏帧同步策略","tags":["帧同步"],"categories":"游戏","author":"龚国玮","excerpt":"\n介绍帧同步问题的基本概念和常见解决方案。我并没有做过这些工作，分享的知识都是我对它感兴趣，在网上看了许多经验后整理的。\n\n","link":"/posts/multiplayer-frame-sync","content":"\n介绍帧同步问题的基本概念和常见解决方案。我并没有做过这些工作，分享的知识都是我对它感兴趣，在网上看了许多经验后整理的。\n\n<!-- more -->\n\n-   Lockstep state update 锁步状态更新\n-   Client prediction 客户端预测\n-   server reconcilation 服务端和解\n\n## 多人游戏的运作方式\n\n游戏程序的玩家当前状态随时间和玩家的输入会进行变化。也就是说游戏是有状态的程序。多人游戏也不例外，但由于多人玩家之间存在交互，复杂性会更高。\n\n例如贪吃蛇游戏，我们假设它的操作会发送到服务器，那它的核心游戏逻辑应该是：\n\n1.  客户端读取用户输入改变蛇的方向，也可以没有输入，然后发送给服务端\n1.  服务端接收消息，根据消息改变蛇的方向，将蛇的“头”移动一个单位空间\n1.  服务端检查蛇是否撞到了墙壁或者自己，如果撞到了游戏结束，给客户端发送响应消息，更新客户端的画面。如果没有撞到，则继续接收客户端发送的消息，同时也要响应给客户端消息，告诉客户端，蛇目前的状态。\n\n服务端接收该消息做出对应的动作，这个过程会以固定的间隔运行。每一次循环都被称为 frame 或 tick。\n\n客户端将解析服务端发送的消息，也就是每一帧的动作，渲染到游戏华中中。\n\n## 锁步状态更新\n\n为了确保所有客户端都同步帧，最简单的方法是让客户端以固定的间隔向服务器发送更新。发送的消息包含用户的输入，当然也可以发送 no user input。\n\n服务器收集“所有用户”的输入后，就可以生成下一次 frame 帧。  \n  \n\n\n![1](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/1.jpg)  \n  \n\n\n上图演示了客户端与服务端的交互过程。T0 ~ T1 时间段，客户端保持等待，或者说空闲状态，直到服务器响应 frame，等待时间的大小取决于网络质量，约 50 毫秒到 500 毫秒，人眼能够注意到任何超过 100 毫秒的延迟，因此这个等待时间对于某些游戏来说是不可接受的。\n\n锁步状态更新，还有一个问题。**游戏的延迟来自最慢的用户** 。\n\n![2](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/2.jpg)\n\n上图有两个客户端。客户端 B 的网络比较差，A 和 B 都在 T0 时间点向服务器发送了用户输入，A 的请求在 T1 到达服务端，B 的请求在 T2 到达服务端，前面我们提到，服务器需要收集“所有用户”的请求后才开始工作，因此需要到 T2 时间点才开始生成 frame。\n\n因为 Client B 比较慢，我们“惩罚”了所有的玩家。\n\n假如我们不等待所有客户端的用户输入，低延迟玩家又会获得优势，因为它的输入到达服务器的时间更短，会更快处理。例如，两个玩家 A、B 同时互相射击预期是同时死亡，但是 A 玩家延迟比 B 玩家更低，因此在处理 B 玩家的用户输入时，A 玩家已经干掉 B 玩家了。\n\n小结一下，锁步状态更新存在的问题，如下。\n\n-   游戏画面是否卡顿，取决于最慢的玩家\n-   客户端需要等待来自服务器的响应，否则不会渲染画面\n-   连接非常活跃，客户端需要定期发送一些无用的心跳包，以便服务器可以确定它拥有生成 frame 所需的所有信息\n\n回合制类型的游戏大多数使用这种方法，因为玩家确实需要等待，例如《炉石传说》。\n\n对于慢节奏的游戏，少量延迟也是可以接受的，例如《QQ农场》。\n\n但是对于快节奏的游戏，锁步状态更新的这些问题都是致命的，不可能操纵游戏人物进入某一个建筑，500 毫秒后，我才能进入。我们一起来看看下一种方法。\n\n## 客户端预测\n\n客户端预测，在玩家的计算机上，运行游戏逻辑，来模拟游戏的行为，而不是等待服务器更新。\n\n例如我们生成 Tn 时间点的游戏状态，我们需要 Tn-1 时间点的所有玩家状态和 Tn-1 时间点所有玩家的输入。\n\n假设，我们现在的固定频率为 1 s，每 1s 需要给服务器发送一个请求，获取玩家状态并更新玩家的状态。\n\n![3](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/3.jpg)\n\n在 T0 时间点，客户端将用户的输入发送到服务器，用于获取 T1 时间点的游戏状态。在 T1 时间点，客户端已经可以渲染画面了，实际上客户端的响应是在 T3 时刻，也就是说客户端没有等待来自服务器的响应。\n\n使用这个方法，需要满足一些前置条件：\n\n-   客户端拥有游戏运行逻辑所需的所有条件\n-   玩家状态的更新逻辑是确定性的，即没有随机性，或者可以以某种方式保证确定性，例如客户端和服务器使用同样的公式以及随机种子，可以保证具有随机性的同时，产生的结果具有确定性。这样保证了客户端和服务器在给定相同输入的情况下产生相同的游戏状态\n\n满足这两点，客户端预测的结果也不一定总是对的。就比如刚提到的，使用相同的公式以及相同的随机种子，进行伪随机算法，但不同平台的浮点计算，可能会存在微小的差异。\n\n再设想一个场景，如下图。\n\n![4](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/4.jpg)\n\n客户端 A 尝试使用 T0 时间点的信息模拟 T1 时间点上的游戏状态，但客户端 B 也在 T0 时间点提交了用户输入，客户端 A 并不知道这个用户输入。\n\n这意味着客户端 A 对 T1 时间的预测将是错误的是，但！由于客户端 A 仍然从服务器接收 T1 时间点的状态，因此客户端有机会在 T3 时间点修正错误。\n\n客户端需要知道，自己的预测是否正确，以及如何修正错误。\n\n修正错误通常叫做 Reconcilation 和解。\n\n需要根据上下文来实现和解部分，下面我们通过一个简单的例子来理解这个概念。这个例子只是抛弃我们的预测，并将其游戏状态替换为服务器响应的正确状态。\n\n-   客户端需要维护 2 个缓冲区，一个用于预测 PredictionBuffer，一个用于用户输入 InputBuffer 。它们是预测这个行为需要的上下文，请记住，预测 Tn 时刻，需要 Tn-1 的状态和 Tn-1 时刻的用户输入。它们一开始都为空  \n      \n    ![5](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/5.jpg)  \n      \n\n-   玩家点击鼠标，移动游戏角色到下一个位置。此时，玩家输入的移动信息 Input 0 存储在 InputBuffer 中，客户端将生成预测 Prediction 1，存储在 PredictionBuffer 中，预测将展示在玩家画面中  \n      \n    ![6](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/6.jpg)  \n      \n\n-   客户端收到服务器响应的 State0 ，发现与客户端的预测不匹配，我们将Prediction 1 替换为 State 0，并使用 Input 0 和 State 0 重新计算，得到 Prediction 2，这个重新计算的过程，就是 Reconcilation 和解  \n      \n    ![7](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/7.jpg)  \n      \n\n-   和解后，我们从缓冲区中删除 State 0 和 Input 0  \n      \n    ![8](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/8.jpg)\n\n这种和解的方式有一个明显的缺点，如果服务器响应的游戏状态和客户端预测差异太大，则游戏画面可能会出现错误。例如我们预测敌人在 T0 时间点向南移动，但在 T3 时间点，我们意识到它在向北移动，然后通过使用服务器的响应进行和解，敌人将从北“飞到”正确的位置。\n\n有一些方法可以解决此问题，这里不展开讨论，感兴趣可以搜一下实体插值 Entity Interpolation。\n\n小结一下，客户端预测技术，让客户端以自己的更新频率运行，与服务器的更新频率无关，所以服务器如果出现阻塞，不会影响客户端的帧。\n\n但它也带来复杂性，如下。\n\n-   需要在客户端处理更多的状态和逻辑，比如我们前面提到的缓冲区和预测逻辑\n-   需要和解来自服务器的状态（正确的游戏状态）与预测之前的冲突\n\n还给我们带来了敌人从南飞到北的问题。\n\n目前为止，我们都在讨论客户端，接下来看看服务端如何解决帧同步。\n\n## 服务端和解\n\n利用服务端解决帧同步问题，首先需要解决的是网络延迟带来的问题。如下图。\n\n![9](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/9.jpg)\n\n用户 A 在 T 处进行了操作（比如按下了一个技能键），该操作应该在 T+20ms 处理，但由于延迟，服务器在 T+120ms 才接收到输入。\n\n在游戏中，用户做出指定操作后，应该立即有反应。立即有反应，这个立即是多久，取决于游戏的类型，比如之前我们提到的回合制，它的立即可能是几十秒。我们可以通过 T + X，表示立即反应的时间，T 代表用户的输入时刻，X 代表的是延迟。X 可以为 0，这代表真正的立即 :-)\n\n解决这个问题的思路，与之前客户端预测中使用的办法类似，就是通过客户端的用户输入，来和解服务器中的玩家游戏状态。\n\n所有的用户输入，都需要时间戳进行标记，该时间戳用于告诉服务器，什么时刻处理此用户输入。\n\n![10](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%B8%A7%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/10.jpg)\n\n为什么在同一水平线上，Client A 的时间是 Time X，而 Server 的时间是 Time Y？  \n因为客户端和服务端独立运行，通常时间会有所不同，在多人游戏中，我们可以特殊处理其中的差异。在特殊处理时，我们应该使客户端的时间大于服务端的时间，因为这样可以存在更大的灵活性\n\n上图演示了一个客户端与服务端之间的交互。\n\n1.  客户端发送带有时间戳的输入。客户端告诉服务器在 X 时间点应该发生用户输入的效果\n1.  服务端在 Y 时间点收到请求\n1.  在 Y+1 时间点，即红色框的地方，服务端开始和解，服务端将 X 时间点的用户输入应用于最新的游戏状态，以保证 X 的 Input 发生在 X 时间点\n1.  服务端发送响应，该响应中包含时间戳\n\n服务端和解部分（上图红色底色部分），主要维护 3 个部分，如下。\n\n-   GameStateHistory，在一定时间范围内玩家在游戏中的状态\n-   ProcessedUserInput，在一定时间范围内处理的用户输入的历史记录\n-   UnprocessedUserInput，已收到但未处理的用户输入，也是在一定的时间内\n\n服务端和解过程，如下。\n\n1.  当服务端收到来自用户的输入时，首先将其放入 UnprocessedUserInput 中\n1.  等待服务端开始同步帧，检查 UnprocessedUserInput 中是否存在任何早于当前帧的用户输入\n1.  如果没有，只需要将最新的 GameState 更新为当前用户的输入，并执行游戏逻辑，然后广播到客户端\n1.  如果有，则表示之前生成的某些游戏状态由于缺少部分用户输入而出错，需要和解，也就是更正。首先需要找到最早的，未处理的用户输入，假设它在时间 N 上，我们需要从 GameStateHistory 中获取时间 N 对应的 GameState 以及从 ProcessedUserInput 获取时间 N 上用户的输入\n1.  使用这 3 条数据，就可以创建一个准确的游戏状态，然后将未处理的输入 N 移动到 ProcessingUserInput，用于之后的和解\n1.  更新 GameStateHistory 中的游戏状态\n1.  重复步骤 4 ~ 6，直到从 N 的时间点到最新的游戏状态\n1.  服务端将最新帧广播给所有玩家"},{"title":"记一次交通事故赔付流程","tags":[],"categories":"朝花夕拾","author":"龚国玮","excerpt":"\n2023 年 10 月 10 日 20:00 左右，我发生了一次交通事故。我是第一次遇见这样的事，处理流程记录下来分享给各位。目前已拿到赔偿。\n\n发生交通事故，第一时间拨打交警电话 122 ，其次就","link":"/posts/pay-for-a-traffic-accident","content":"\n2023 年 10 月 10 日 20:00 左右，我发生了一次交通事故。我是第一次遇见这样的事，处理流程记录下来分享给各位。目前已拿到赔偿。\n\n发生交通事故，第一时间拨打交警电话 122 ，其次就是救护车电话 120，不要让肇事司机送你去医院，避免在路上造成二次伤害，我拨打 120 后，15 分钟左右救护车就到达现场了。\n\n拨打 120 后，第一时间告知医护人员如下内容。\n\n我在华阳地铁口的非机动车道发生了交通事故（说一个有明显特征的地点，救护车第一时间找到你），这个手机号可以联系到我，我目前没有生命危险，对方的车牌号是 XXX。\n\n接下来就是治疗了，全程我没有掏一分钱，全部是肇事司机去支付的。\n\n在医院治疗时，交警和肇事司机会来找你，完成道路交通事故认定书。注意，此时肇事司机的车辆一定是在交警大队的，在事故认定书流程没有结束前，不要让肇事司机取到车。\n\n我没有住院，在会诊完毕后，拿到了一张病情通知单，医生会在上面写建议休息多少天，这是谈误工费的主要依据之一。\n\n赔偿是你治疗结束谈的，我当天就开始谈赔偿了。赔偿方式有两种，一种是私了，一种是走保险。看你自己决定，我是走保险，同时我也建议走保险。\n\n私了，他就要把该给的都给了，如误工费、医药费、营养费（如果住院了才有这个费用）、物损费（一般私了可能肇事方还会多给一点）。\n\n走保险。在交通事故认定书上，会有对方的保险公司名称，你需要明确告诉他，你不私，要走保险。之后可以打电话到保险公司客服，通过车牌号查询对方是否报备本次交通事故，报备后会有理赔人员联系你，谈赔偿。\n\n谈赔偿这里要划重点，首先是误工费，双休的公司你就告诉理赔人员，要求按照 21.75 天算日薪。理赔人员都想坑你（觉得你不懂），在我身上发生就了这样的事，理赔员上来就告诉我，按照我所在省份的平均工资赔偿（200元/天）。理赔人员会要求你出示薪资流水，一般是半年，假如你是刚来这个公司，没有半年的流水，拍劳动合同的薪资就可以了。\n\n物损费，去找维修机构，定损，让他们出示维修清单以及对应的费用即可，之后理赔人员会去维修机构拍照。\n\n我的是单车，修好以后，把换下来的部件和新的部件，拍照发给理赔人员，他们要复勘。完成复勘后的第 2 天，我就拿到了赔偿。\n\n整个流程，从发生事故到拿到赔偿，共计 13 天时间。"},{"title":"不同业务场景下，Redis数据结构选型","tags":["Redis"],"categories":"数据库","author":"龚国玮","excerpt":"\n## Strings - 字符串\n字符串类型，Redis 最基本的数据类型，代表一个字节序列。\n\n字节序列，多字节数据的存放顺序。存放顺序分为大端字节序（big endian）和小端字节序（litt","link":"/posts/redis-data-structure-selection","content":"\n## Strings - 字符串\n字符串类型，Redis 最基本的数据类型，代表一个字节序列。\n\n字节序列，多字节数据的存放顺序。存放顺序分为大端字节序（big endian）和小端字节序（little endian），举个例子，一个数值变量 x 使用两个字节存储，地址为 0x1122，那么高位字节是 0x11，低位字节是 0x22。只有读取时需要连续读取超过一个字节数据时才需要考虑字节序问题。\n\n- 大端字节序是人类读数值的顺序，低位字节在后，高位字节在前。\n- 小端字节序则相反，低位字节在前，高位字节在后。\n\n\n![BIG-ENDIAN.png](https://weizicoding-1318098637.cos.ap-chengdu.myqcloud.com/%E9%80%89Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%97%B6%E7%9C%8B%E4%B8%80%E7%9C%BC.png)\n  \n## Lists - 列表\nLists 是按插入顺序排序的字符串列表。\n\n## Sets - 集合\nSets 是 String 类型的无序集合，它存储的集合成员具有唯一性，也就是说具有去重的特性。举个例子。\n\n- 通过 Redis-Cli 操作 Redis-server，存储 user 1 喜欢的数据库\n\n```shell\nSADD user:1:like redis\n\n(integer) 1\n\nSADD user:1:like mysql\n\n(integer) 1\n\nSADD user:1:like mysql\n\n(integer) 0\n```\n\n- 查看 user 1 喜欢的数据库，存储了两次 mysql，但只保存了一条\n\n```shell\nSMEMBERS user:1:like\n\n1) \"mysql\"\n\n2) \"redis\"\n```\n\n使用 sets 可以在 O(1) 时间添加、删除和测试数据是否存在。\n  \n## Hashes - 哈希\nHashes 是记录字段-值（key-value）的集合。Redis Hashes 类似 Go 的 map，Python 的 dictionaries，Java 的 HashMaps\n\n## Sorted sets - 有序集合\nSorted sets 和 Sets 与一样，是 String 类型的无序集合，它存储的集合成员具有唯一性，区别顾名思义，它是有序的，通过每个字符串的分数来维持顺序。\n\n## Streams - 流\nStreams 的作用就像一个只附加消息的日志，Streams 按照事件发生的顺序进行记录，然后将其联合起来一起进行处理。网上大部分博客都把这个数据类型等价于实现消息队列。\n\n## Geospatial indexes - 地理空间索引\nGeospatial indexes 的地理位置索引对于在给定的经纬度或边界内寻找位置非常有用。\n\n## Bitmaps - 位图\nBitmaps 是 String 类型的扩展，它把字符串当做一个位向量并允许对字符串进行位操作。位是计算机中最小的单位，使用它进行储存将非常节省空间，特别适合一些数据量大且使用二值统计的场景，例如签到。\n\n## Bitfields - 位域\n\nBitfields 可以获取、增加、更新任何比特长度的整数值。Bitfields 支持原子读、写和增量操作，它是管理计数器的好选择。假如你开发了一款游戏，想要记录被杀的怪物数量和玩家的金币数量，你的游戏非常火爆，这两个计数器至少需要 32 位宽。此时我们可以用每个玩家的 Bitfields 来表示这些计数器。\n\n- 新玩家默认有 1000 金币，计数器偏移量为 0 \n```shell\n> BITFIELD player:1:stats SET u32 #0 1000\n1) (integer) 0\n```\n\n- 杀死囚禁茜灵的反派后，获得 50 金币，并更新被杀的怪物数量的计数器，即偏移 1。\n```shell\n> BITFIELD player:1:stats INCRBY u32 #0 50 INCRBY u32 #1 1\n1) (integer) 1050\n2) (integer) 1\n```\n\n谁是茜灵？她！这是我们公司游戏的女主角\n\n![临界指令-茜灵](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/592f0982a2a74b5e8d6b45f69f35f8ca~tplv-k3u1fbpfcp-watermark.image?)\n\n- 付给铁匠 999 金币，购买一件治安臂装\n```shell\n> BITFIELD player:1:stats INCRBY u32 #0 -999\n1) (integer) 51\n```\n\n- 查看玩家的数据\n```shell\n> BITFIELD player:1:stats GET u32 #0 GET u32 #1\n1) (integer) 51\n2) (integer) 1\n```\n\n## HyperLogLog - ???\nHyperLogLog 是一种基数估计的概率数据结构，以几乎完美的准确性换取高效的空间利用。比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}， 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。"},{"title":"使用WebSocket推送消息，客户端报错","tags":["消息编码"],"categories":"计算机网络","author":"龚国玮","excerpt":"\n今天一天时间，解决了一个问题，写下此篇博客进行复盘。\n\n","link":"/posts/remote-party-closed-the-ws-conn-without","content":"\n今天一天时间，解决了一个问题，写下此篇博客进行复盘。\n\n<!-- more -->\n\n我使用 WS 协议推消息，该消息使用二进制+ proto 编码，推送后，在服务端没有报任何错，但是在客户端报错：\n::: danger\n\nThe remote party closed the WebSocket connection without completing the close handshake.\n\n::: \n\nproto 消息的数据结构为 `Map[int]string`，当 int 为 1 或 100 时，客户端不会报错，当 int 为 999 或 1000 时就会报错。\n\n\n我从客户端的报错信息判断是服务端关闭了 ws 的连接，因此，我在关闭 ws 的函数中打断点，并没有进去。\n随后我查看了 proto 编码出来的数据，发现如果数据中出现了**乱码**，客户端就会报错，为了避免乱码，我使用 base64 进行了加密，推送仍然失败，此时 base64 加密后的消息，没有任何乱码。\n\n此时，我怀疑是封包问题，查看了 WS 文档，发现 WS 底层使用了 base64 加密，也就可能是我使用 base64 加密的原因，我又将消息体换成了 md5，客户端仍然无法收到包。\n\n我的协议设计为 `data_len+route+message`，此时我尝试仅加密数据部分，即 `data_len+route+base64(message)+<<<EOF(自定义结束符)`，客户端接收消息成功。\n当我以为万事大吉的时候，我发现 data_len 从 uint32 变为二进制后，出现了乱码！导致客户端又出现了同样的报错。\n\n继续查看 WS 文档，发现 WS 协议的底层，对于文本，会使用 UTF-8 进行解码，解码失败，就会断开连接，我在代码中，对发送的数据进行 UTF-8 的校验，果然，发送失败的数据，校验结果是 false，成功的校验都是 true。\n难道我要把协议中的 data_len 和 route 都封装成 string ？这显然不可能，网关收发消息，随时都在使用，我使用 string 的方式时，客户端也需要进行反射，额外增加了 6 次操作。\n\n继续看文档，发现 WS 支持二进制模式和文本模式，我**将 WS WriteMessage 的 type 修改为二进制**，并将之前的 base64 加密代码删除，客户端成功接收消息并解码。"},{"title":"小小汇编，轻松拿捏！","tags":[],"categories":"汇编小册","author":"龚国玮","excerpt":"\n计算机并不聪明。这听起来可能违反直觉。但我向你保证，你的计算机所做的一切都可以用两个值来表示：0 和 1 。\n\n0 和 1 ，看起来很好理解吧，就是两个数字而已，但它们并不是总是很容易理解。计算机经","link":"/posts/compilation-booklet/preamble","content":"\n计算机并不聪明。这听起来可能违反直觉。但我向你保证，你的计算机所做的一切都可以用两个值来表示：0 和 1 。\n\n0 和 1 ，看起来很好理解吧，就是两个数字而已，但它们并不是总是很容易理解。计算机经过很长时间的逐层构建，这些层产生了今天高效、令人难以置信的机器。但是，这些层有时也让学习计算机感觉像是一场可怕的噩梦，因为要学习的东西太多了。\n\n我们现在许多高级语言，直接操作 CPU 通常是不必要的，因为这些语言足够快，可以满足我们的大部分需求。但当你使用汇编语言时，你可以做一些很酷的事，如下。\n- 编写操作系统\n- 制作驱动程序\n- 密码学相关工作\n- 制作病毒的黑客 (😈 桀桀桀桀......)\n\n即使我们可能永远不需要编写汇编，但了解计算机汇编级别的工作方式后，可以帮助我们看到在计算机上所做的所有其他事情。事实上，当我写代码的时候，我很高兴它不是汇编，使用汇编编写程序是非常原始的 - 必须自己考虑每一件事。\n\n这有点像是一名赛车手。赛车手不需要了解汽车在引擎盖下做什么。他只需使用油门、方向盘、雨刮器等。但是，如果他对发动机、制动器、车轮和其他机械设备有较低层次的了解，他可以利用这些知识更好的驾驭赛车。例如，他可能在比赛中闻到难闻的气味。对赛车低层次设备不了解的人可能会忽略这个标志，但这可能意味着他的汽车，在驾驶过程中发生了一些应该调整的问题，比如在漂移的时候，刹车需要在某一刻踩的更轻一点？\n\n希望这个系列的博客，可以让我们一起揭开计算机神秘的底层面纱。\n\n- [汇编小册(一) CPU](./1.md)\n- [汇编小册(二) 嘿！CPU！我要去北京](./2.md)\n- [汇编小册(三) 指令周期](./3.md)\n- [汇编小册(四) 指令映射到机器代码](./4.md)\n- [汇编小册(五) 电与物理世界](./5.md)\n- [汇编小册(六) 常见的汇编语言种类](./6.md)\n- [汇编小册(七) 数据](./7.md)\n- [汇编小册(八) 寄存器](./8.md)\n- [汇编小册(九) 动起来](./9.md)"}]
