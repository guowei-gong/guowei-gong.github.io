import{_ as d}from"./ValaxyMain.vue_vue_type_style_index_0_lang-CBf5hEqz.js";import{a as p,p as i,o as u,c as h,w as e,f,q as g,r as a,g as t,h as s}from"./app-BZDWLfP1.js";import"./YunFooter.vue_vue_type_script_setup_true_lang-Be0Mb7hY.js";import"./YunCard.vue_vue_type_script_setup_true_lang-Dhwia5MJ.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-Bqy1HhVw.js";import"./index-C7yU5XnD.js";const _=t("p",null,"今天一天时间，解决了一个问题，写下此篇博客进行复盘。",-1),b=t("p",null,"我使用 WS 协议推消息，该消息使用二进制+ proto 编码，推送后，在服务端没有报任何错，但是在客户端报错：",-1),$=t("div",{class:"danger custom-block"},[t("p",{class:"custom-block-title"},[t("span",{lang:"en"},"DANGER"),t("span",{lang:"zh-CN"},"警告")]),t("p",null,"The remote party closed the WebSocket connection without completing the close handshake.")],-1),w=t("p",null,[s("proto 消息的数据结构为 "),t("code",null,"Map[int]string"),s("，当 int 为 1 或 100 时，客户端不会报错，当 int 为 999 或 1000 时就会报错。")],-1),S=t("p",null,[s("我从客户端的报错信息判断是服务端关闭了 ws 的连接，因此，我在关闭 ws 的函数中打断点，并没有进去。 随后我查看了 proto 编码出来的数据，发现如果数据中出现了"),t("strong",null,"乱码"),s("，客户端就会报错，为了避免乱码，我使用 base64 进行了加密，推送仍然失败，此时 base64 加密后的消息，没有任何乱码。")],-1),W=t("p",null,"此时，我怀疑是封包问题，查看了 WS 文档，发现 WS 底层使用了 base64 加密，也就可能是我使用 base64 加密的原因，我又将消息体换成了 md5，客户端仍然无法收到包。",-1),k=t("p",null,[s("我的协议设计为 "),t("code",null,"data_len+route+message"),s("，此时我尝试仅加密数据部分，即 "),t("code",null,"data_len+route+base64(message)+<<<EOF(自定义结束符)"),s("，客户端接收消息成功。 当我以为万事大吉的时候，我发现 data_len 从 uint32 变为二进制后，出现了乱码！导致客户端又出现了同样的报错。")],-1),v=t("p",null,"继续查看 WS 文档，发现 WS 协议的底层，对于文本，会使用 UTF-8 进行解码，解码失败，就会断开连接，我在代码中，对发送的数据进行 UTF-8 的校验，果然，发送失败的数据，校验结果是 false，成功的校验都是 true。 难道我要把协议中的 data_len 和 route 都封装成 string ？这显然不可能，网关收发消息，随时都在使用，我使用 string 的方式时，客户端也需要进行反射，额外增加了 6 次操作。",-1),y=t("p",null,[s("继续看文档，发现 WS 支持二进制模式和文本模式，我"),t("strong",null,"将 WS WriteMessage 的 type 修改为二进制"),s("，并将之前的 base64 加密代码删除，客户端成功接收消息并解码。")],-1),U={__name:"remote-party-closed-the-ws-conn-without",setup(T,{expose:m}){const n=JSON.parse('{"title":"使用WebSocket推送消息，客户端报错","description":"","frontmatter":{"title":"使用WebSocket推送消息，客户端报错","date":"2023-10-27T00:00:00.000Z","updated":"2023-10-27T00:00:00.000Z","categories":"计算机网络","tags":["消息编码"],"excerpt_type":"text"},"headers":[],"relativePath":"pages/posts/remote-party-closed-the-ws-conn-without.md","path":"/home/runner/work/guowei-gong.github.io/guowei-gong.github.io/pages/posts/remote-party-closed-the-ws-conn-without.md","lastUpdated":1718246058000}'),l=p(),r=n.frontmatter||{};return l.meta.frontmatter=Object.assign(l.meta.frontmatter||{},n.frontmatter||{}),i("pageData",n),i("valaxy:frontmatter",r),globalThis.$frontmatter=r,m({frontmatter:{title:"使用WebSocket推送消息，客户端报错",date:"2023-10-27T00:00:00.000Z",updated:"2023-10-27T00:00:00.000Z",categories:"计算机网络",tags:["消息编码"],excerpt_type:"text"}}),(o,V)=>{const c=d;return u(),h(c,{frontmatter:f(r)},{"main-content-md":e(()=>[_,g(" more "),b,$,w,S,W,k,v,y]),"main-header":e(()=>[a(o.$slots,"main-header")]),"main-header-after":e(()=>[a(o.$slots,"main-header-after")]),"main-nav":e(()=>[a(o.$slots,"main-nav")]),"main-content":e(()=>[a(o.$slots,"main-content")]),"main-content-after":e(()=>[a(o.$slots,"main-content-after")]),"main-nav-before":e(()=>[a(o.$slots,"main-nav-before")]),"main-nav-after":e(()=>[a(o.$slots,"main-nav-after")]),comment:e(()=>[a(o.$slots,"comment")]),footer:e(()=>[a(o.$slots,"footer")]),aside:e(()=>[a(o.$slots,"aside")]),"aside-custom":e(()=>[a(o.$slots,"aside-custom")]),default:e(()=>[a(o.$slots,"default")]),_:3},8,["frontmatter"])}}};export{U as default};
