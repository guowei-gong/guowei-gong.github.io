import{_ as u}from"./ValaxyMain.vue_vue_type_style_index_0_lang-CBf5hEqz.js";import{a as h,p as d,o as _,c as m,w as e,f as p,r as n,g as t,h as o}from"./app-BZDWLfP1.js";import"./YunFooter.vue_vue_type_script_setup_true_lang-Be0Mb7hY.js";import"./YunCard.vue_vue_type_script_setup_true_lang-Dhwia5MJ.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-Bqy1HhVw.js";import"./index-C7yU5XnD.js";const f=t("p",null,"我们通过指令来要求 CPU 去做某事。假设我们给出一个指令：嘿，CPU，你能把这两个数字加在一起吗？当 CPU 准备好处理该指令时，它会启动一个包含 3 个主要阶段的循环：",-1),P=t("ol",null,[t("li",null,"Fetch：从内存中获取数据"),t("li",null,"Decode：解码该数据，获得指令"),t("li",null,"Execute：执行指令")],-1),U=t("h2",{id:"fetch-获取",tabindex:"-1"},[o("Fetch 获取 "),t("a",{class:"header-anchor",href:"#fetch-获取","aria-label":'Permalink to "Fetch 获取"'},"​")],-1),C=t("p",null,"在第一阶段，CPU 必须从内存中获取指令数据，这样 CPU 才可以看到你要求它做什么。",-1),g=t("p",null,"内存，也称为随机存取内存或 RAM，是你的计算机拥有的一种短期存储。而有长期的存储位置，例如磁盘。但是当我们需要暂时保留某些东西时，或者需要更快的访问响应速度时，我们会使用内存。",-1),b=t("p",null,"发挥我们的想象力，把 CPU 看作是一个仓库。CPU 访问你的内存时，有点像去装有箱子的货架。每个箱子（数据）都有一个位置（内存地址），你可以在其中查看箱子内的内容（读取该内存地址处的数据）。你还可以将所有内容从箱子里拿出来（清除该内存地址处的内容），然后将新内容放入箱子中（在该内存地址存储新数据）。",-1),$=t("p",null,"在内存中，所有数据都以电的形式存储（这里我有一个疯狂的想法，CPU 好像一名能够控制雷电的法师）。因为我们将数据存储为电，所以当你的计算机关闭后，并且不再有电流向它时，你存储的所有内容都会被清除！这有点像每天晚上仓库关闭时，所有的包裹都被扔掉了。这就是为什么我们将其称为短期记忆，我们将重要的东西存储在磁盘中，这是我们的长期存储，以免被丢弃。",-1),v=t("p",null,"我们的大货架（内存）有非常大的空间，来存放我们的箱子。但是在仓库中移动大箱子可能又慢又麻烦。因此，为了更快和临时的存储，我们在仓库安装了一组有编号的小货架，我们可以在其中放置较小的箱子。这个小货架，就是我们 CPU 的寄存器。",-1),k=t("p",null,"寄存器是 CPU 可以存储小块数据的地方。假如我们需要将两个数字相加。",-1),x=t("p",null,"首先，CPU 检索等式所需的第一个数字。由于 CPU 一次只能做一件事，因此它需要放下第一个数字才能抓取下一个数字。因此，它暂时将第一个数字存储到寄存器中。",-1),T=t("p",null,"接下来，CPU 获取等式中的第二个数字。CPU 现在拥有将两个数字相加所需的所有信息。它继续执行相加的指令，输出新数组，即相加的结果，然后继续从内存中获取数据。",-1),w=t("p",null,"现在你可能会问，既然寄存器更快，为什么我们不将所有内容都存储在寄存器中，而还要存在内存中呢？我们寄存器的空间是有限的。实际大小取决于计算机的硬件。你可能会获得大约 16 个通用寄存器来存储你的数据。但有些寄存器只能在内部使用，不能直接访问。",-1),D=t("p",null,"内存可以轻松容纳超过寄存器容量的 1500 万倍！由于计算机必须处理如此多的数据，因此我们的寄存器很快就会耗尽空间。因此，任何我们不需要用于指令的数据，我们都会放在内存中。",-1),F=t("h2",{id:"decode-解码",tabindex:"-1"},[o("Decode 解码 "),t("a",{class:"header-anchor",href:"#decode-解码","aria-label":'Permalink to "Decode 解码"'},"​")],-1),E=t("p",null,"现在我们已经获取了数据，那这些数据实际上是什么样子的？",-1),Z=t("p",null,"我们之前提到过，计算机只能读取数字。因此，我们存储的所有数据都必须以计算机可以读取的方式表示。",-1),y=t("p",null,"这些数字所代表的内容包括五大类：",-1),A=t("ul",null,[t("li",null,"指令"),t("li",null,"数值"),t("li",null,"字母"),t("li",null,"寄存器"),t("li",null,"内存地址")],-1),B=t("p",null,"当指令周期到达解码步骤时，CPU 将识别它正在查看的数据类型。",-1),N=t("p",null,"每个 CPU 都有一组物理内置在芯片中的指令，你可以将其视为与 CPU 可以执行的数字的操作列表。因为从 Fetch 获取阶段获取的数据只是数字，所以 CPU 可以将其看到的数字与设置的指令列表进行比较来解码指令。",-1),V=t("table",null,[t("thead",null,[t("tr",null,[t("th",null,"数值"),t("th",null,"指令")])]),t("tbody",null,[t("tr",null,[t("td",null,"1"),t("td",null,"add")]),t("tr",null,[t("td",null,"2"),t("td",null,"sub")]),t("tr",null,[t("td",null,"…"),t("td",null,"…")])])],-1),L=t("p",null,"解码获取的数据，第一部分是操作码，它是 CPU 可以运行的操作的唯一标识符。在将两个数字相加的情况下，该操作码就是 add 。",-1),M=t("p",null,"获取的下一个数字是要执行的参数。举一个假设的例子，假设我们有一个这样的指令：",-1),O=t("p",null,[t("code",null,"add 3, 4")],-1),R=t("p",null,[o("我们的操作码是 "),t("code",null,"add"),o("，我们的参数是 3 和 4 。")],-1),S=t("h2",{id:"execute-执行",tabindex:"-1"},[o("Execute 执行 "),t("a",{class:"header-anchor",href:"#execute-执行","aria-label":'Permalink to "Execute 执行"'},"​")],-1),j=t("p",null,"在获取的数据被解码后，CPU 得到一个可以执行的指令。",-1),J=t("p",null,"如果指令是算术的（如加法或减法）或逻辑指令（如比较两位数以给出真或假），则有一个额外的步骤在算术逻辑单元或 ALU 处。这个单位负责做数学运算。完成数学运算后，ALU 将返回一个值，该值存储在寄存器中，直到指令需要它。",-1),Y={__name:"3",setup(q,{expose:r}){const s=JSON.parse('{"title":"汇编小册(三) 指令周期","description":"","frontmatter":{"title":"汇编小册(三) 指令周期","hide":"index","date":"2023-08-22T00:00:00.000Z","updated":"2023-08-22T00:00:00.000Z","categories":"汇编小册"},"headers":[{"level":2,"title":"Fetch 获取","slug":"fetch-获取","link":"#fetch-获取","children":[]},{"level":2,"title":"Decode 解码","slug":"decode-解码","link":"#decode-解码","children":[]},{"level":2,"title":"Execute 执行","slug":"execute-执行","link":"#execute-执行","children":[]}],"relativePath":"pages/posts/compilation-booklet/3.md","path":"/home/runner/work/guowei-gong.github.io/guowei-gong.github.io/pages/posts/compilation-booklet/3.md","lastUpdated":1718246058000}'),i=h(),a=s.frontmatter||{};return i.meta.frontmatter=Object.assign(i.meta.frontmatter||{},s.frontmatter||{}),d("pageData",s),d("valaxy:frontmatter",a),globalThis.$frontmatter=a,r({frontmatter:{title:"汇编小册(三) 指令周期",hide:"index",date:"2023-08-22T00:00:00.000Z",updated:"2023-08-22T00:00:00.000Z",categories:"汇编小册"}}),(l,G)=>{const c=u;return _(),m(c,{frontmatter:p(a)},{"main-content-md":e(()=>[f,P,U,C,g,b,$,v,k,x,T,w,D,F,E,Z,y,A,B,N,V,L,M,O,R,S,j,J]),"main-header":e(()=>[n(l.$slots,"main-header")]),"main-header-after":e(()=>[n(l.$slots,"main-header-after")]),"main-nav":e(()=>[n(l.$slots,"main-nav")]),"main-content":e(()=>[n(l.$slots,"main-content")]),"main-content-after":e(()=>[n(l.$slots,"main-content-after")]),"main-nav-before":e(()=>[n(l.$slots,"main-nav-before")]),"main-nav-after":e(()=>[n(l.$slots,"main-nav-after")]),comment:e(()=>[n(l.$slots,"comment")]),footer:e(()=>[n(l.$slots,"footer")]),aside:e(()=>[n(l.$slots,"aside")]),"aside-custom":e(()=>[n(l.$slots,"aside-custom")]),default:e(()=>[n(l.$slots,"default")]),_:3},8,["frontmatter"])}}};export{Y as default};
